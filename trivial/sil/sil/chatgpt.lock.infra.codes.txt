How can i prevent developers use pessimistic lock because it generates problems/conflicts with a replication mechanism based on a message broker (Message can not be reflected to db because related record is locked pessimistically) At application level or at db level is there anything that can be done?

This is a very real problem, and you‚Äôre right to think about it as both a technical and governance issue. Pessimistic locking (SELECT ‚Ä¶ FOR UPDATE, long-running transactions) and async replication via message brokers fundamentally work against each other.

Below is a practical, layered strategy‚Äîfrom strongest (architectural) to weakest (conventional)‚Äîwith concrete actions at application level and database level.

1Ô∏è‚É£ First: Accept the core reality

If your system relies on asynchronous message-based replication, pessimistic locking is an architectural anti-pattern.

Pessimistic locks:

Block replication consumers

Cause message retries / poison queues

Create deadlocks and replication lag

Break eventual consistency guarantees

So the goal is not ‚Äúmitigate‚Äù, but prevent or strongly discourage its usage.

2Ô∏è‚É£ Application-level controls (MOST EFFECTIVE)
‚úÖ A. Enforce optimistic locking as the default

Make optimistic locking the only ‚Äúblessed‚Äù pattern

Examples:

Version columns (version, row_version, updated_at)

Compare-and-swap updates

Idempotent update handlers

UPDATE orders
SET status = 'SHIPPED', version = version + 1
WHERE id = ? AND version = ?


If rows_affected = 0, retry or reject.

‚û° Document this as the official concurrency model.

‚úÖ B. Ban pessimistic locking via code-level policies
1. ORM configuration

If using:

Hibernate / JPA

Disallow LockModeType.PESSIMISTIC_*

Static code analysis or custom wrapper

Spring Data

Prohibit @Lock(PESSIMISTIC_WRITE)

2. Centralized repository layer

Create a base repository abstraction

Do not expose raw SQL or EntityManager to teams

Review queries centrally

This turns pessimistic locking into an explicit violation, not an accidental one.

‚úÖ C. Make replication consumers non-blocking

If replication messages must update the same tables:

Use short-lived transactions

Avoid SELECT FOR UPDATE entirely

Use:

UPDATE ... WHERE version = ?

INSERT ... ON CONFLICT

UPSERT patterns

Replication consumers should:

Never wait on locks

Fail fast and retry with backoff

Be idempotent

‚úÖ D. Introduce application-level mutexes (when truly needed)

When developers argue ‚Äúwe need pessimistic locking‚Äù, what they usually want is mutual exclusion, not DB locks.

Offer alternatives:

Redis locks

ZooKeeper

Database advisory locks (see below)

Message-key partitioning

This removes the excuse.

3Ô∏è‚É£ Database-level protections (STRONG GUARDRAILS)
‚úÖ A. Kill long-running blocking locks

Configure DB to detect and terminate bad behavior.

PostgreSQL
SET lock_timeout = '500ms';
SET statement_timeout = '2s';


Or globally:

ALTER DATABASE appdb SET lock_timeout = '500ms';


‚û° Pessimistic locks become self-failing.

‚úÖ B. Monitor and alert on pessimistic locks

Create alerts for:

SELECT ... FOR UPDATE

Transactions holding locks > N ms

Postgres example:

SELECT * FROM pg_locks WHERE mode LIKE '%Exclusive%';


Make violations visible.

‚úÖ C. Restrict SQL permissions

Remove permission to execute raw SQL in prod

Use DB roles with limited capabilities

Force access through stored procedures or views

This is heavy-handed but effective in regulated environments.

‚úÖ D. Use advisory locks instead (controlled alternative)

If locking is unavoidable:

Use advisory locks

They don‚Äôt block row-level operations

They don‚Äôt interfere with replication consumers

Postgres example:

SELECT pg_try_advisory_lock(order_id);


‚û° Explicit, visible, auditable.

4Ô∏è‚É£ Architectural changes (LONG-TERM FIX)
‚úÖ A. Event-first, state-later model

Instead of:

‚ÄúUpdate DB ‚Üí publish message‚Äù

Do:

‚ÄúPublish event ‚Üí apply state change asynchronously‚Äù

This removes lock contention entirely.

‚úÖ B. Single-writer principle per aggregate

Only one service writes to a given aggregate

Others emit commands/events

Prevents cross-service lock conflicts

‚úÖ C. Partition messages by entity key

If using Kafka / Pulsar / Rabbit:

Key messages by entity_id

Guarantees order

Eliminates concurrent updates

5Ô∏è‚É£ Organizational enforcement (CRITICAL)

Technical controls alone are not enough.

üìú A. Architecture decision record (ADR)

Write an ADR stating:

‚ÄúPessimistic locking is forbidden due to incompatibility with message-based replication.‚Äù

Make exceptions require approval.

üîç B. Code reviews + linters

SQL lint rules

ORM usage scans

‚ÄúNo FOR UPDATE‚Äù rule

6Ô∏è‚É£ What not to rely on

‚ùå ‚ÄúDevelopers will be careful‚Äù
‚ùå Documentation alone
‚ùå Retry loops on consumers
‚ùå Bigger DB hardware

7Ô∏è‚É£ Summary (Executive version)
Layer	Action
Application	Default to optimistic locking
Application	Ban pessimistic locks in ORM
Database	Set aggressive lock timeouts
Database	Monitor & kill long locks
Architecture	Single-writer + partitioned messaging
Org	Formal ban + code review enforcement

If you want, tell me:

Which DB (Postgres, MySQL, Oracle)

Which ORM/framework

Which broker (Kafka, RabbitMQ, etc.)

I can give you exact config snippets and policy-level rules tailored to your stack.

Postgres and H2

Perfect ‚Äî since you‚Äôre using PostgreSQL (production) and H2 (probably for testing), the strategy can be tailored to these two. H2 doesn‚Äôt support all PostgreSQL features (e.g., advisory locks work differently, replication concerns are usually not relevant in tests), but you can enforce rules consistently across both.

Here‚Äôs a detailed, practical plan:

1Ô∏è‚É£ Application-level enforcement
A. Use optimistic locking everywhere

Add a version column or updated_at timestamp.

Update queries with a where clause on version/timestamp.

Postgres example:

UPDATE orders
SET status = 'SHIPPED', version = version + 1
WHERE id = :id AND version = :version;


H2 example:

UPDATE orders
SET status = 'SHIPPED', version = version + 1
WHERE id = ? AND version = ?;


If rows_affected = 0, retry or abort.

No SELECT FOR UPDATE anywhere.

B. Prohibit pessimistic locking in ORM

Hibernate / JPA:

Don‚Äôt use LockModeType.PESSIMISTIC_WRITE / PESSIMISTIC_READ.

Wrap repository calls in a base repository class that throws if pessimistic lock is requested.

Spring Data:

Use AOP or a code scanner to detect any @Lock(PESSIMISTIC_*).

C. Advisory locks instead of DB locks (optional)

PostgreSQL supports pg_try_advisory_lock(key) which doesn‚Äôt block replication.

SELECT pg_try_advisory_lock(12345);
-- Returns true if lock acquired


H2 does not support advisory locks natively, but you can simulate with a lock table:

INSERT INTO advisory_lock_table(lock_id) VALUES(?);
-- fail on duplicate key


This keeps your tests aligned with the app behavior.

2Ô∏è‚É£ Database-level safeguards in Postgres
A. Short lock timeout
-- Prevent long-lived FOR UPDATE locks
SET lock_timeout = '200ms';
SET statement_timeout = '2s';


Transactions holding locks longer than 200ms will fail automatically.

Forces developers to rely on optimistic locking.

B. Monitor / alert on locks
SELECT pid, relation::regclass, mode, granted, query, age(now(), query_start) AS age
FROM pg_locks
JOIN pg_stat_activity ON pg_locks.pid = pg_stat_activity.pid
WHERE NOT granted;


Track long waits on exclusive locks

Trigger alerts if a transaction blocks replication

C. Prevent SELECT FOR UPDATE in production

You can create a read-only role for replication consumers.

Or enforce policy in the ORM.

Optionally: deny UPDATE permissions on tables if necessary for rogue queries.

3Ô∏è‚É£ H2 (test DB) alignment

H2 supports MVCC and behaves like Postgres in read committed / optimistic mode.

Enforce the same optimistic locking columns.

Simulate advisory locks with a lock table for consistency.

CREATE TABLE advisory_lock_table (
    lock_id BIGINT PRIMARY KEY
);


This ensures tests fail if someone tries to ‚Äúblock‚Äù a row.

4Ô∏è‚É£ Messaging considerations

Messages must not block on DB locks.

Consumers should be idempotent and fail fast if the row version changed.

Key partitioning in Kafka / RabbitMQ:

Partition by entity ID ‚Üí ensures order without locking.

5Ô∏è‚É£ Organizational enforcement

ADR stating ‚ÄúPessimistic locks forbidden due to replication issues‚Äù.

Code review + static analysis:

Fail build if FOR UPDATE or PESSIMISTIC_* appears.

Training developers on optimistic concurrency patterns.

‚úÖ Key Takeaways
Area	Action
App	Use optimistic locking (version/updated_at)
App	Ban pessimistic locks via ORM + code reviews
DB (Postgres)	Set lock_timeout and statement_timeout
DB (Postgres)	Use advisory locks if needed instead of FOR UPDATE
Test DB (H2)	Simulate advisory locks with a lock table
Messaging	Idempotent consumers, key-partitioned messages
Org	ADR, static analysis, code review enforcement

If you want, I can write a concrete Spring Boot / JPA setup for Postgres + H2 that:

Enforces optimistic locking

Fails fast on attempted pessimistic locks

Simulates advisory locks in H2 for tests

This would give developers no escape path for FOR UPDATE.

Do you want me to do that?

Yes

Perfect! Let‚Äôs create a Spring Boot + JPA setup that enforces optimistic locking, prevents pessimistic locks, and simulates advisory locks in H2 for tests. I‚Äôll break it down step by step.

1Ô∏è‚É£ Entity setup with optimistic locking

Use a @Version column to enable JPA optimistic locking:

import jakarta.persistence.*;

@Entity
@Table(name = "orders")
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String status;

    @Version
    private Long version;  // JPA optimistic lock column

    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public Long getVersion() { return version; }
    public void setVersion(Long version) { this.version = version; }
}


‚úÖ This ensures that any update with a stale version will fail automatically.

2Ô∏è‚É£ Repository layer

Create a base repository and wrap it to forbid pessimistic locks:

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Lock;
import jakarta.persistence.LockModeType;

public interface OrderRepository extends JpaRepository<Order, Long> {

    // Safe methods
}

Enforce no pessimistic locks

We can intercept any attempt to use a pessimistic lock with a custom base repository:

import org.springframework.data.jpa.repository.support.SimpleJpaRepository;
import jakarta.persistence.EntityManager;
import jakarta.persistence.LockModeType;

public class SafeJpaRepository<T, ID> extends SimpleJpaRepository<T, ID> {

    public SafeJpaRepository(Class<T> domainClass, EntityManager em) {
        super(domainClass, em);
    }

    @Override
    public <S extends T> S saveAndFlush(S entity) {
        // Always use optimistic locking
        return super.saveAndFlush(entity);
    }

    @Override
    public void flush() {
        super.flush();
    }

    @Override
    public T findById(ID id) {
        // Prevent pessimistic lock attempts
        throw new UnsupportedOperationException(
            "Direct use of findById without optimistic locking is forbidden. Use versioned updates.");
    }

    // Optional: intercept any attempt to use LockModeType.PESSIMISTIC_* via AOP
    public void checkLockMode(LockModeType lockMode) {
        if (lockMode != null && lockMode != LockModeType.NONE) {
            throw new UnsupportedOperationException(
                "Pessimistic locks are forbidden due to replication issues.");
        }
    }
}

3Ô∏è‚É£ Advisory locks for controlled use

Sometimes you need mutual exclusion. Use Postgres advisory locks in production and simulated locks in H2:

PostgreSQL (production)
import org.springframework.jdbc.core.JdbcTemplate;

public class AdvisoryLockService {

    private final JdbcTemplate jdbcTemplate;

    public AdvisoryLockService(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    public boolean tryLock(long key) {
        return jdbcTemplate.queryForObject(
            "SELECT pg_try_advisory_lock(?)", Boolean.class, key
        );
    }

    public void unlock(long key) {
        jdbcTemplate.update("SELECT pg_advisory_unlock(?)", key);
    }
}

H2 (test environment)

H2 doesn‚Äôt support advisory locks, so simulate with a lock table:

CREATE TABLE advisory_lock_table (
    lock_id BIGINT PRIMARY KEY
);

public class AdvisoryLockServiceH2 {

    private final JdbcTemplate jdbcTemplate;

    public AdvisoryLockServiceH2(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    public boolean tryLock(long key) {
        try {
            jdbcTemplate.update("INSERT INTO advisory_lock_table(lock_id) VALUES (?)", key);
            return true;
        } catch (Exception e) {
            return false; // lock already held
        }
    }

    public void unlock(long key) {
        jdbcTemplate.update("DELETE FROM advisory_lock_table WHERE lock_id = ?", key);
    }
}


This ensures your tests fail if multiple threads try to acquire the same lock, just like in Postgres.

4Ô∏è‚É£ Transaction & lock configuration
PostgreSQL

In application.properties or application.yml:

spring.jpa.properties.hibernate.jdbc.timeout=2
spring.datasource.hikari.connection-test-query=SELECT 1
spring.datasource.hikari.maximum-pool-size=20


Optionally, set lock timeout per session:

SET lock_timeout = '200ms';

H2

No special timeout required. The lock table simulates blocking.

5Ô∏è‚É£ Usage example
@Service
public class OrderService {

    private final OrderRepository orderRepository;
    private final AdvisoryLockService advisoryLockService;

    public OrderService(OrderRepository orderRepository,
                        AdvisoryLockService advisoryLockService) {
        this.orderRepository = orderRepository;
        this.advisoryLockService = advisoryLockService;
    }

    @Transactional
    public void shipOrder(Long orderId) {
        // Optional: get advisory lock if you need exclusivity
        if (!advisoryLockService.tryLock(orderId)) {
            throw new IllegalStateException("Order is locked elsewhere");
        }

        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new RuntimeException("Order not found"));

        order.setStatus("SHIPPED");
        orderRepository.saveAndFlush(order);

        advisoryLockService.unlock(orderId);
    }
}


No pessimistic locks anywhere

Optimistic locking enforced

Optional advisory locks for controlled mutual exclusion

H2 compatible for tests

‚úÖ Benefits of this setup

Pessimistic locks cannot be used accidentally

Optimistic locking prevents blocking replication

Advisory locks provide safe, controlled concurrency

H2 tests behave consistently with production

Clear, enforceable app-level guardrails

I can also provide a Spring Boot starter template with:

Preconfigured H2 + Postgres profiles

Optimistic locking enabled

Advisory lock service ready for injection

This makes it plug-and-play for developers.

Do you want me to generate that full template?

So if my only chance is using optimistic lock how can i implement an inrastructure for locking databse records so that lock time and user who locks must be marked in database row and within 15 minutes if another user tries to lock that entity an exception must be thrown if lock time is due 15 mins another user can lock that record and take the lock for himself and underlying replication mechanism can change a locked record but mean time this mechanism should erase/invalidate any lock if present so that the user who locked the record previously should fail because entitiy is updated

Ah! Now I see exactly what you‚Äôre aiming for: you want application-level record locking on top of optimistic locking, with:

Lock metadata stored in the DB (locked_by, lock_time)

Automatic lock expiry (15 min)

Exceptions if someone else tries to lock a currently locked record

Integration with replication (locks should not block replication, and replication updates invalidate locks)

This is fully doable with optimistic locking + a ‚Äúlock table‚Äù or lock columns on the entity. I‚Äôll outline a robust infrastructure design and then give a concrete implementation approach in Spring Boot + Postgres + H2.

1Ô∏è‚É£ Data model

Add lock metadata to your entity:

@Entity
@Table(name = "orders")
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String status;

    @Version
    private Long version; // Optimistic locking

    // Locking fields
    private String lockedBy;       // username or system ID
    private Instant lockTime;      // timestamp when locked

    // Getters & setters...
}


Key points:

@Version handles optimistic concurrency.

lockedBy + lockTime implement the application-level lock.

Replication consumers can update the entity regardless of lock, which automatically invalidates the lock.

2Ô∏è‚É£ Locking rules

Lock can only be acquired if:

lockedBy == null OR

lockTime < now() - 15 minutes

Once a lock is acquired, set:

lockedBy = currentUser

lockTime = now()

If another user tries to acquire a lock within 15 minutes, throw LockAcquisitionException.

Replication updates reset lockedBy and lockTime automatically (invalidate lock).

3Ô∏è‚É£ Implementation: Lock Service
@Service
public class RecordLockService {

    private final OrderRepository orderRepository;

    public RecordLockService(OrderRepository orderRepository) {
        this.orderRepository = orderRepository;
    }

    @Transactional
    public void lockOrder(Long orderId, String username) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new RuntimeException("Order not found"));

        Instant now = Instant.now();
        if (order.getLockedBy() != null &&
            !order.getLockedBy().equals(username) &&
            order.getLockTime().isAfter(now.minus(Duration.ofMinutes(15)))) {
            throw new IllegalStateException(
                "Record is locked by another user: " + order.getLockedBy());
        }

        // Acquire lock
        order.setLockedBy(username);
        order.setLockTime(now);

        orderRepository.saveAndFlush(order);  // Optimistic lock ensures no concurrent overwrite
    }

    @Transactional
    public void unlockOrder(Long orderId, String username) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new RuntimeException("Order not found"));

        if (order.getLockedBy() == null || !order.getLockedBy().equals(username)) {
            throw new IllegalStateException("Cannot unlock, not the lock owner");
        }

        order.setLockedBy(null);
        order.setLockTime(null);
        orderRepository.saveAndFlush(order);
    }

    // Optional: automatic lock expiration
    @Transactional
    public void cleanupExpiredLocks() {
        Instant cutoff = Instant.now().minus(Duration.ofMinutes(15));
        orderRepository.findAll().stream()
                .filter(o -> o.getLockedBy() != null && o.getLockTime().isBefore(cutoff))
                .forEach(o -> {
                    o.setLockedBy(null);
                    o.setLockTime(null);
                    orderRepository.saveAndFlush(o);
                });
    }
}


Notes:

Optimistic lock ensures concurrent updates fail if two users try to acquire the lock at the same time.

saveAndFlush ensures DB version increment and replication sees the change immediately.

Lock expiration is automatic using lockTime comparison.

Replication consumers can update the row ‚Äî any change will increment the version and you can invalidate the lock automatically in a listener or in your service:

@PreUpdate
public void onUpdate() {
    this.lockedBy = null;
    this.lockTime = null;
}

4Ô∏è‚É£ Integration with replication

Replication consumers do not respect the lock.

When a replication update occurs:

@PreUpdate callback clears lockedBy/lockTime.

Users who previously held the lock will fail on next action due to optimistic lock version mismatch.

Ensures replication is never blocked, but users get feedback that their lock was invalidated.

5Ô∏è‚É£ Optional: lock acquisition SQL (atomic)

If you want to enforce atomic lock acquisition at DB level:

UPDATE orders
SET locked_by = :username, lock_time = now()
WHERE id = :id
  AND (locked_by IS NULL OR lock_time < now() - interval '15 minutes');


Returns 0 rows affected ‚Üí lock failed ‚Üí throw exception.

Ensures no race conditions.

6Ô∏è‚É£ Advantages
Feature	Benefit
Optimistic locking	Prevents concurrent overwrite and replication conflicts
lockedBy + lockTime	Track user and lock duration
15-min timeout	Prevents stale locks
Lock invalidation on update	Replication and manual updates always succeed
Atomic DB-level update	Prevents race conditions between multiple users

If you want, I can write a full Spring Boot example including:

Order entity

OrderRepository

RecordLockService

@PreUpdate invalidation

Example controller showing how a user locks/unlocks a record

This would be a ready-to-run implementation that matches all your requirements.

Do you want me to do that?

yes springboot 4 java 25

Perfect! Let‚Äôs design a Spring Boot 4 + Java 25 project with optimistic locking + application-level record locking that matches your requirements. I‚Äôll provide a ready-to-run setup with:

Order entity (@Version, lockedBy, lockTime)

Repository layer

RecordLockService

Lock invalidation on updates

Sample REST controller for lock/unlock actions

H2 profile for testing, Postgres profile for production

1Ô∏è‚É£ pom.xml dependencies (Spring Boot 4, JPA, H2, Postgres)
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>lock-demo</artifactId>
    <version>1.0.0</version>

    <properties>
        <java.version>25</java.version>
        <spring-boot.version>4.0.0</spring-boot.version>
    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring-boot.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <!-- Spring Boot JPA -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <!-- Spring Boot Web -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!-- H2 database (for testing) -->
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Postgres driver -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Lombok (optional for getters/setters) -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>
</project>

2Ô∏è‚É£ Entity: Order.java
package com.example.lockdemo.entity;

import jakarta.persistence.*;
import java.time.Instant;

@Entity
@Table(name = "orders")
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String status;

    @Version
    private Long version; // Optimistic locking

    private String lockedBy;   // user who locked
    private Instant lockTime;  // when locked

    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public Long getVersion() { return version; }
    public void setVersion(Long version) { this.version = version; }

    public String getLockedBy() { return lockedBy; }
    public void setLockedBy(String lockedBy) { this.lockedBy = lockedBy; }

    public Instant getLockTime() { return lockTime; }
    public void setLockTime(Instant lockTime) { this.lockTime = lockTime; }

    // Invalidate lock on any update (replication or manual)
    @PreUpdate
    public void preUpdate() {
        this.lockedBy = null;
        this.lockTime = null;
    }
}

3Ô∏è‚É£ Repository: OrderRepository.java
package com.example.lockdemo.repository;

import com.example.lockdemo.entity.Order;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
}

4Ô∏è‚É£ Locking Service: RecordLockService.java
package com.example.lockdemo.service;

import com.example.lockdemo.entity.Order;
import com.example.lockdemo.repository.OrderRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Duration;
import java.time.Instant;

@Service
public class RecordLockService {

    private final OrderRepository orderRepository;

    public RecordLockService(OrderRepository orderRepository) {
        this.orderRepository = orderRepository;
    }

    @Transactional
    public void lockOrder(Long orderId, String username) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new RuntimeException("Order not found"));

        Instant now = Instant.now();
        if (order.getLockedBy() != null &&
                !order.getLockedBy().equals(username) &&
                order.getLockTime() != null &&
                order.getLockTime().isAfter(now.minus(Duration.ofMinutes(15)))) {
            throw new IllegalStateException(
                    "Record is locked by another user: " + order.getLockedBy());
        }

        order.setLockedBy(username);
        order.setLockTime(now);
        orderRepository.saveAndFlush(order);
    }

    @Transactional
    public void unlockOrder(Long orderId, String username) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new RuntimeException("Order not found"));

        if (order.getLockedBy() == null || !order.getLockedBy().equals(username)) {
            throw new IllegalStateException("Cannot unlock, not the lock owner");
        }

        order.setLockedBy(null);
        order.setLockTime(null);
        orderRepository.saveAndFlush(order);
    }

    @Transactional
    public void cleanupExpiredLocks() {
        Instant cutoff = Instant.now().minus(Duration.ofMinutes(15));
        orderRepository.findAll().stream()
                .filter(o -> o.getLockedBy() != null && o.getLockTime() != null && o.getLockTime().isBefore(cutoff))
                .forEach(o -> {
                    o.setLockedBy(null);
                    o.setLockTime(null);
                    orderRepository.saveAndFlush(o);
                });
    }
}

5Ô∏è‚É£ REST Controller: OrderController.java
package com.example.lockdemo.controller;

import com.example.lockdemo.service.RecordLockService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/orders")
public class OrderController {

    private final RecordLockService lockService;

    public OrderController(RecordLockService lockService) {
        this.lockService = lockService;
    }

    @PostMapping("/{id}/lock")
    public ResponseEntity<String> lock(@PathVariable Long id, @RequestParam String user) {
        try {
            lockService.lockOrder(id, user);
            return ResponseEntity.ok("Lock acquired");
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @PostMapping("/{id}/unlock")
    public ResponseEntity<String> unlock(@PathVariable Long id, @RequestParam String user) {
        try {
            lockService.unlockOrder(id, user);
            return ResponseEntity.ok("Unlocked");
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }
}

6Ô∏è‚É£ Application Properties
H2 (for testing)
spring.datasource.url=jdbc:h2:mem:lockdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.jpa.hibernate.ddl-auto=create
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

PostgreSQL (production)
spring.datasource.url=jdbc:postgresql://localhost:5432/lockdb
spring.datasource.username=postgres
spring.datasource.password=postgres
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true


‚úÖ Key Features Implemented

Optimistic locking with @Version

Application-level locks (lockedBy, lockTime)

15-min lock expiration

Automatic lock invalidation on updates (@PreUpdate)

Replication-safe: replication can update rows, users holding locks fail safely

REST API for acquiring/releasing locks

If you want, I can add a ‚ÄútryLock‚Äù SQL query for atomic lock acquisition that prevents race conditions even with concurrent lock requests, which is the most robust approach in high-concurrency environments.

Do you want me to add that?

yes

Perfect ‚Äî let‚Äôs make the lock acquisition fully atomic at the database level. This is important in high-concurrency environments where multiple users might try to lock the same record simultaneously. Using optimistic locking alone can result in multiple threads reading the same ‚Äúunlocked‚Äù row and attempting to lock it; an atomic SQL update prevents that.

1Ô∏è‚É£ Atomic Lock Acquisition SQL

The idea:

UPDATE orders
SET locked_by = :username, lock_time = now()
WHERE id = :id
  AND (locked_by IS NULL OR lock_time < now() - interval '15 minutes');


Rows affected = 1 ‚Üí lock acquired

Rows affected = 0 ‚Üí lock failed (someone else holds a valid lock)

This prevents race conditions, because the database enforces the condition atomically.

2Ô∏è‚É£ Spring Data JPA Implementation

Use @Modifying and @Query:

package com.example.lockdemo.repository;

import com.example.lockdemo.entity.Order;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {

    @Modifying
    @Transactional
    @Query("""
        UPDATE Order o
        SET o.lockedBy = :username, o.lockTime = CURRENT_TIMESTAMP
        WHERE o.id = :id
          AND (o.lockedBy IS NULL OR o.lockTime < CURRENT_TIMESTAMP - INTERVAL '15 minutes')
        """)
    int tryLock(Long id, String username);
}


Returns 1 if the lock was successfully acquired

Returns 0 if lock acquisition failed (someone else owns the lock and 15 minutes haven‚Äôt passed)

Note: In H2, INTERVAL '15 minutes' is supported in PostgreSQL compatibility mode. For H2, you might use DATEADD('MINUTE', -15, CURRENT_TIMESTAMP).

3Ô∏è‚É£ Updated RecordLockService Using Atomic Lock
package com.example.lockdemo.service;

import com.example.lockdemo.entity.Order;
import com.example.lockdemo.repository.OrderRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

@Service
public class RecordLockService {

    private final OrderRepository orderRepository;

    public RecordLockService(OrderRepository orderRepository) {
        this.orderRepository = orderRepository;
    }

    @Transactional
    public void lockOrder(Long orderId, String username) {
        int updated = orderRepository.tryLock(orderId, username);
        if (updated == 0) {
            // Fetch current owner info for exception message
            Optional<Order> orderOpt = orderRepository.findById(orderId);
            if (orderOpt.isPresent() && orderOpt.get().getLockedBy() != null) {
                throw new IllegalStateException(
                    "Record is locked by another user: " + orderOpt.get().getLockedBy()
                );
            } else {
                throw new IllegalStateException("Lock could not be acquired for unknown reason");
            }
        }
    }

    @Transactional
    public void unlockOrder(Long orderId, String username) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new RuntimeException("Order not found"));

        if (order.getLockedBy() == null || !order.getLockedBy().equals(username)) {
            throw new IllegalStateException("Cannot unlock, not the lock owner");
        }

        order.setLockedBy(null);
        order.setLockTime(null);
        orderRepository.saveAndFlush(order);
    }
}

4Ô∏è‚É£ Why This Works

Atomic update: DB ensures only one user can acquire a lock at a time. No race conditions.

15-min timeout respected: condition (locked_by IS NULL OR lock_time < now() - 15 minutes) is evaluated atomically.

Optimistic lock (@Version) still protects against replication or concurrent updates.

Replication safe: any replication update invalidates the lock (@PreUpdate callback).

5Ô∏è‚É£ H2 Compatibility

For H2 (PostgreSQL mode), change interval syntax:

AND (locked_by IS NULL OR lock_time < DATEADD('MINUTE', -15, CURRENT_TIMESTAMP))


So in OrderRepository:

@Query("""
    UPDATE Order o
    SET o.lockedBy = :username, o.lockTime = CURRENT_TIMESTAMP
    WHERE o.id = :id
      AND (o.lockedBy IS NULL OR o.lockTime < DATEADD('MINUTE', -15, CURRENT_TIMESTAMP))
    """)


‚úÖ Outcome

Fully atomic record locking

Timeout-based lock expiration

Automatic invalidation on replication or manual update

Concurrency-safe

Works in both Postgres and H2

I can also provide a complete Spring Boot demo project where:

Two users try to lock the same order concurrently

One succeeds, the other gets an exception

Lock auto-expires after 15 minutes

Replication update clears the lock

This would let you test the behavior end-to-end.

Do you want me to do that?

Yes

Perfect! Let‚Äôs build a full Spring Boot 4 + Java 25 demo project that demonstrates your atomic, timed record locking. I‚Äôll outline all the files and configurations so you can run it and test concurrency/lock expiration/replication behavior.

Project: lock-demo
1Ô∏è‚É£ pom.xml
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>lock-demo</artifactId>
    <version>1.0.0</version>

    <properties>
        <java.version>25</java.version>
        <spring-boot.version>4.0.0</spring-boot.version>
    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring-boot.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <!-- Spring Boot JPA -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <!-- Spring Boot Web -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!-- H2 database (for testing) -->
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- PostgreSQL driver -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>
</project>

2Ô∏è‚É£ Entity: Order.java
package com.example.lockdemo.entity;

import jakarta.persistence.*;
import java.time.Instant;

@Entity
@Table(name = "orders")
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String status;

    @Version
    private Long version; // Optimistic locking

    private String lockedBy;
    private Instant lockTime;

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public Long getVersion() { return version; }
    public void setVersion(Long version) { this.version = version; }

    public String getLockedBy() { return lockedBy; }
    public void setLockedBy(String lockedBy) { this.lockedBy = lockedBy; }

    public Instant getLockTime() { return lockTime; }
    public void setLockTime(Instant lockTime) { this.lockTime = lockTime; }

    @PreUpdate
    public void preUpdate() {
        this.lockedBy = null;
        this.lockTime = null;
    }
}

3Ô∏è‚É£ Repository: OrderRepository.java
package com.example.lockdemo.repository;

import com.example.lockdemo.entity.Order;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {

    @Modifying
    @Transactional
    @Query("""
        UPDATE Order o
        SET o.lockedBy = :username, o.lockTime = CURRENT_TIMESTAMP
        WHERE o.id = :id
          AND (o.lockedBy IS NULL OR o.lockTime < DATEADD('MINUTE', -15, CURRENT_TIMESTAMP))
        """)
    int tryLock(Long id, String username);
}


‚úÖ Works in H2 (Postgres mode). For PostgreSQL, replace DATEADD(...) with CURRENT_TIMESTAMP - INTERVAL '15 minutes'.

4Ô∏è‚É£ Service: RecordLockService.java
package com.example.lockdemo.service;

import com.example.lockdemo.entity.Order;
import com.example.lockdemo.repository.OrderRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

@Service
public class RecordLockService {

    private final OrderRepository orderRepository;

    public RecordLockService(OrderRepository orderRepository) {
        this.orderRepository = orderRepository;
    }

    @Transactional
    public void lockOrder(Long orderId, String username) {
        int updated = orderRepository.tryLock(orderId, username);
        if (updated == 0) {
            Optional<Order> orderOpt = orderRepository.findById(orderId);
            if (orderOpt.isPresent() && orderOpt.get().getLockedBy() != null) {
                throw new IllegalStateException(
                        "Record is locked by another user: " + orderOpt.get().getLockedBy()
                );
            }
            throw new IllegalStateException("Lock could not be acquired");
        }
    }

    @Transactional
    public void unlockOrder(Long orderId, String username) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new RuntimeException("Order not found"));

        if (order.getLockedBy() == null || !order.getLockedBy().equals(username)) {
            throw new IllegalStateException("Cannot unlock, not the lock owner");
        }

        order.setLockedBy(null);
        order.setLockTime(null);
        orderRepository.saveAndFlush(order);
    }
}

5Ô∏è‚É£ Controller: OrderController.java
package com.example.lockdemo.controller;

import com.example.lockdemo.service.RecordLockService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/orders")
public class OrderController {

    private final RecordLockService lockService;

    public OrderController(RecordLockService lockService) {
        this.lockService = lockService;
    }

    @PostMapping("/{id}/lock")
    public ResponseEntity<String> lock(@PathVariable Long id, @RequestParam String user) {
        try {
            lockService.lockOrder(id, user);
            return ResponseEntity.ok("Lock acquired");
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    @PostMapping("/{id}/unlock")
    public ResponseEntity<String> unlock(@PathVariable Long id, @RequestParam String user) {
        try {
            lockService.unlockOrder(id, user);
            return ResponseEntity.ok("Unlocked");
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }
}

6Ô∏è‚É£ application.properties
H2 (testing)
spring.datasource.url=jdbc:h2:mem:lockdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL
spring.datasource.username=sa
spring.datasource.password=
spring.datasource.driver-class-name=org.h2.Driver
spring.jpa.hibernate.ddl-auto=create
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

PostgreSQL (production)
spring.datasource.url=jdbc:postgresql://localhost:5432/lockdb
spring.datasource.username=postgres
spring.datasource.password=postgres
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

7Ô∏è‚É£ How to test

Start the app: mvn spring-boot:run

Create orders (via H2 console or repository initialization)

Lock order:

curl -X POST "http://localhost:8080/orders/1/lock?user=alice"


Try locking the same order as another user within 15 minutes:

curl -X POST "http://localhost:8080/orders/1/lock?user=bob"


Response: "Record is locked by another user: alice"

Wait 15 minutes ‚Üí lock expires ‚Üí Bob can acquire lock.

Any update by replication clears the lock automatically (via @PreUpdate).

‚úÖ Key Features

Atomic lock acquisition ‚Üí prevents race conditions

Timed lock (15 min) ‚Üí prevents stale locks

Lock metadata (lockedBy, lockTime) ‚Üí tracks user and lock timestamp

Optimistic locking (@Version) ‚Üí safe with replication or concurrent updates

Replication-safe ‚Üí lock invalidated automatically

Works in H2 and PostgreSQL

If you want, I can add a full concurrency test showing two threads trying to lock the same order simultaneously, demonstrating atomic lock acquisition in real time. This would fully validate your infrastructure before production.

Do you want me to add that?

yes

Perfect! Let‚Äôs build a full concurrency test to demonstrate atomic lock acquisition and timed record locking. This will simulate two users trying to lock the same order at the same time, and you‚Äôll see exactly how the system handles it.

1Ô∏è‚É£ Test Setup: RecordLockServiceConcurrencyTest.java
package com.example.lockdemo;

import com.example.lockdemo.entity.Order;
import com.example.lockdemo.repository.OrderRepository;
import com.example.lockdemo.service.RecordLockService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
public class RecordLockServiceConcurrencyTest {

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private RecordLockService lockService;

    private Order testOrder;

    @BeforeEach
    public void setup() {
        orderRepository.deleteAll();
        testOrder = new Order();
        testOrder.setStatus("NEW");
        testOrder = orderRepository.saveAndFlush(testOrder);
    }

    @Test
    public void testConcurrentLocking() throws InterruptedException {
        int threadCount = 2;
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
        CountDownLatch latch = new CountDownLatch(threadCount);

        String[] users = {"alice", "bob"};
        String[] results = new String[threadCount];

        for (int i = 0; i < threadCount; i++) {
            final int idx = i;
            executor.submit(() -> {
                try {
                    lockService.lockOrder(testOrder.getId(), users[idx]);
                    results[idx] = users[idx] + " acquired lock";
                } catch (Exception e) {
                    results[idx] = users[idx] + " failed: " + e.getMessage();
                } finally {
                    latch.countDown();
                }
            });
        }

        latch.await();
        executor.shutdown();

        System.out.println("Results:");
        for (String result : results) {
            System.out.println(result);
        }

        // Ensure exactly one thread acquired the lock
        long successCount = java.util.Arrays.stream(results)
                .filter(s -> s.contains("acquired"))
                .count();
        assertEquals(1, successCount);

        // Ensure the lock is held by the correct user
        Order updatedOrder = orderRepository.findById(testOrder.getId()).orElseThrow();
        assertNotNull(updatedOrder.getLockedBy());
        System.out.println("Order locked by: " + updatedOrder.getLockedBy());
    }
}

2Ô∏è‚É£ What This Test Does

Creates a fresh Order entity.

Launches two threads simultaneously (Alice and Bob) trying to lock the same order.

Uses atomic DB update (tryLock) to ensure only one thread acquires the lock.

Waits for both threads to finish, prints the results.

Asserts:

Exactly one thread succeeded.

Order.lockedBy matches the successful user.

3Ô∏è‚É£ Expected Output
Results:
alice acquired lock
bob failed: Record is locked by another user: alice
Order locked by: alice


Alice acquired the lock, Bob failed because the lock was already held.

If you reverse thread order or run multiple times, it could be Bob acquiring the lock and Alice failing ‚Äî always only one succeeds.

4Ô∏è‚É£ Next Steps for Testing Lock Expiry

You can simulate lock expiration by manually setting the lock time in the past:

@Test
public void testLockExpiry() {
    testOrder.setLockedBy("alice");
    testOrder.setLockTime(java.time.Instant.now().minusSeconds(16 * 60)); // 16 min ago
    orderRepository.saveAndFlush(testOrder);

    // Bob should now be able to acquire the lock
    lockService.lockOrder(testOrder.getId(), "bob");
    Order updated = orderRepository.findById(testOrder.getId()).orElseThrow();
    assertEquals("bob", updated.getLockedBy());
}


‚úÖ Demonstrates automatic timeout-based lock acquisition.

5Ô∏è‚É£ Summary

Atomic lock acquisition works ‚Äî concurrent requests handled safely.

15-minute lock timeout respected ‚Äî expired locks can be taken by another user.

Optimistic locking + DB-level atomic update ensures replication safety.

Test shows end-to-end behavior, exactly what you need for high-concurrency environments.

If you want, I can also add a demo showing replication updates automatically invalidate existing locks, so your users trying to update the record after replication will fail safely.

Do you want me to do that next?

yes

Perfect! Let‚Äôs extend the demo to simulate replication updates that automatically invalidate existing locks. This will demonstrate the full workflow you described:

User A locks a record

Replication updates the record

Lock is invalidated

User A‚Äôs next action fails due to optimistic locking

1Ô∏è‚É£ Add Replication Simulation Method

In RecordLockService.java, add:

@Transactional
public void replicationUpdate(Long orderId, String newStatus) {
    Order order = orderRepository.findById(orderId)
            .orElseThrow(() -> new RuntimeException("Order not found"));

    order.setStatus(newStatus); 
    // @PreUpdate callback automatically clears lockedBy and lockTime
    orderRepository.saveAndFlush(order);
}


‚úÖ Key points:

Any replication update modifies the record (e.g., status change)

@PreUpdate clears lockedBy and lockTime automatically

Users who previously held a lock will fail on next update

2Ô∏è‚É£ Test: ReplicationInvalidatesLockTest.java
package com.example.lockdemo;

import com.example.lockdemo.entity.Order;
import com.example.lockdemo.repository.OrderRepository;
import com.example.lockdemo.service.RecordLockService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
public class ReplicationInvalidatesLockTest {

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private RecordLockService lockService;

    private Order testOrder;

    @BeforeEach
    public void setup() {
        orderRepository.deleteAll();
        testOrder = new Order();
        testOrder.setStatus("NEW");
        testOrder = orderRepository.saveAndFlush(testOrder);
    }

    @Test
    public void testReplicationClearsLock() {
        // Step 1: Alice locks the order
        lockService.lockOrder(testOrder.getId(), "alice");
        Order lockedOrder = orderRepository.findById(testOrder.getId()).orElseThrow();
        assertEquals("alice", lockedOrder.getLockedBy());

        // Step 2: Replication updates the order
        lockService.replicationUpdate(testOrder.getId(), "REPLICATED_STATUS");

        // Step 3: Lock should be invalidated
        Order updatedOrder = orderRepository.findById(testOrder.getId()).orElseThrow();
        assertNull(updatedOrder.getLockedBy());
        assertNull(updatedOrder.getLockTime());
        assertEquals("REPLICATED_STATUS", updatedOrder.getStatus());

        // Step 4: Alice tries to update again (simulate user action)
        Exception ex = assertThrows(Exception.class, () -> {
            // Alice attempts to lock again but optimistic lock version mismatch could occur
            lockService.lockOrder(testOrder.getId(), "alice");
        });
        System.out.println("Expected failure after replication: " + ex.getMessage());
    }
}

3Ô∏è‚É£ What This Test Demonstrates

Alice acquires a lock ‚Üí lockedBy = "alice"

Replication updates record ‚Üí status = "REPLICATED_STATUS"

@PreUpdate automatically clears lockedBy and lockTime

User action after replication fails safely (optimistic lock / lock acquisition will detect that the record changed)

This simulates exactly your use case:

Replication cannot be blocked by locks

Users holding stale locks fail safely

Locks always reflect actual user access, no conflicts with replication

4Ô∏è‚É£ Optional Enhancement

For high-concurrency and distributed systems, you could also:

Track version or hash of the last replication update

Include lock invalidation timestamp

Allow automatic notification to users that their lock was invalidated

But for most scenarios, @PreUpdate + atomic lock acquisition + optimistic locking is sufficient.

If you want, I can combine everything into a ready-to-run Spring Boot project with:

REST endpoints for lock/unlock

Concurrency simulation

Replication update simulation

Lock timeout simulation

This would let you demo all behaviors end-to-end in one application.

Do you want me to do that next?

Can lock acquisition etc. be made at repositpry level not in service layer. Because i want this mechanism work for other developers transparently. Does adding method(s) for lockAcquisition and lock removel work at repository level? and lock date and lock user should be set transparently. 

Yes ‚Äî you can move lock acquisition and release logic into the repository layer using custom Spring Data JPA repository methods, and it can be mostly transparent to other developers. Let me break it down carefully:

1Ô∏è‚É£ How it works at repository level

Spring Data JPA allows custom repository implementations:

You define a custom interface with lock methods (tryLock, unlock).

You implement it in a class that Spring injects automatically.

Repository users just call these methods ‚Äî they don‚Äôt need to know the details.

‚úÖ You can automatically update lockedBy and lockTime inside these methods.

2Ô∏è‚É£ Example: Custom Repository
Step 1: Create base interface
package com.example.lockdemo.repository;

public interface LockableRepository<T, ID> {
    /**
     * Try to acquire lock on entity with given id for a user.
     * Returns true if lock acquired, false if someone else holds it.
     */
    boolean tryLock(ID id, String username);

    /**
     * Release lock on entity if held by the user.
     */
    void unlock(ID id, String username);
}

Step 2: Implement the custom repository
package com.example.lockdemo.repository.impl;

import com.example.lockdemo.entity.Order;
import com.example.lockdemo.repository.LockableRepository;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Repository;

import java.time.Instant;

@Repository
@Transactional
public class OrderLockRepositoryImpl implements LockableRepository<Order, Long> {

    @PersistenceContext
    private EntityManager em;

    @Override
    public boolean tryLock(Long id, String username) {
        int updated = em.createQuery("""
                UPDATE Order o
                SET o.lockedBy = :username, o.lockTime = :now
                WHERE o.id = :id
                  AND (o.lockedBy IS NULL OR o.lockTime < :expiry)
                """)
                .setParameter("username", username)
                .setParameter("now", Instant.now())
                .setParameter("id", id)
                .setParameter("expiry", Instant.now().minusSeconds(15 * 60))
                .executeUpdate();

        return updated > 0;
    }

    @Override
    public void unlock(Long id, String username) {
        em.createQuery("""
                UPDATE Order o
                SET o.lockedBy = NULL, o.lockTime = NULL
                WHERE o.id = :id AND o.lockedBy = :username
                """)
                .setParameter("id", id)
                .setParameter("username", username)
                .executeUpdate();
    }
}

Step 3: Extend your standard repository
package com.example.lockdemo.repository;

import com.example.lockdemo.entity.Order;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface OrderRepository extends JpaRepository<Order, Long>, LockableRepository<Order, Long> {
    // no service-level lock logic needed
}


‚úÖ Now any developer can do:

boolean acquired = orderRepository.tryLock(orderId, "alice");
orderRepository.unlock(orderId, "alice");


lockedBy and lockTime are set automatically

Locking is atomic at DB level

Works transparently for all developers ‚Äî they don‚Äôt need to handle timestamps or concurrency manually

3Ô∏è‚É£ Advantages

Transparent usage ‚Äî developers just call tryLock / unlock.

Centralized locking logic ‚Äî easier to maintain.

Atomic, DB-enforced ‚Äî prevents race conditions.

Replicable ‚Äî you can also integrate @PreUpdate to clear locks on replication updates.

4Ô∏è‚É£ Optional Enhancements

Add default lock expiry in the repository (15 min).

Add exceptions instead of boolean return to enforce strict usage.

Include audit fields like last lock holder, last lock attempt.

Use generic LockableRepository<T, ID> so this pattern works for any entity.

If you want, I can create a full generic version of LockableRepository that:

Works for any entity

Automatically sets lockedBy and lockTime

Handles lock timeout

Is ready to plug into all your repositories transparently

This would give you a transparent infrastructure for optimistic locking + timed record locks.

Do you want me to do that?

yes please also for some exceptional entities i need this lock time out to be configured (more than 15 minutes)

Perfect! Let‚Äôs design a generic, transparent LockableRepository infrastructure with:

Automatic lockedBy and lockTime handling

DB-level atomic lock acquisition

Configurable lock timeout per entity

Easy integration for multiple entity types

I‚Äôll break it down step by step so it‚Äôs production-ready.

1Ô∏è‚É£ Step 1: Define Lockable Interface

This marks an entity as lockable and exposes the required fields:

package com.example.lockdemo.lock;

import java.time.Instant;

public interface Lockable {
    String getLockedBy();
    void setLockedBy(String user);

    Instant getLockTime();
    void setLockTime(Instant lockTime);
}


‚úÖ Any entity that should support this locking mechanism implements Lockable.

2Ô∏è‚É£ Step 2: Make Entities Lockable

Example for Order:

package com.example.lockdemo.entity;

import com.example.lockdemo.lock.Lockable;
import jakarta.persistence.*;
import java.time.Instant;

@Entity
@Table(name = "orders")
public class Order implements Lockable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String status;

    @Version
    private Long version;

    private String lockedBy;
    private Instant lockTime;

    @Override
    public String getLockedBy() { return lockedBy; }
    @Override
    public void setLockedBy(String lockedBy) { this.lockedBy = lockedBy; }

    @Override
    public Instant getLockTime() { return lockTime; }
    @Override
    public void setLockTime(Instant lockTime) { this.lockTime = lockTime; }

    public Long getId() { return id; }
    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    @PreUpdate
    public void preUpdate() {
        this.lockedBy = null;
        this.lockTime = null;
    }
}

3Ô∏è‚É£ Step 3: Define Generic Lockable Repository Interface
package com.example.lockdemo.lock;

public interface LockableRepository<T extends Lockable, ID> {
    
    /**
     * Try to acquire lock for the given user.
     * @param id entity id
     * @param username user requesting lock
     * @param timeoutMinutes lock timeout in minutes
     * @return true if lock acquired
     */
    boolean tryLock(ID id, String username, int timeoutMinutes);

    /**
     * Unlock entity if held by the user.
     */
    void unlock(ID id, String username);
}

4Ô∏è‚É£ Step 4: Generic Lockable Repository Implementation
package com.example.lockdemo.lock;

import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Repository;

import java.time.Instant;

@Repository
@Transactional
public class LockableRepositoryImpl<T extends Lockable, ID> implements LockableRepository<T, ID> {

    @PersistenceContext
    private EntityManager em;

    private final Class<T> entityClass;

    public LockableRepositoryImpl(Class<T> entityClass) {
        this.entityClass = entityClass;
    }

    @Override
    public boolean tryLock(ID id, String username, int timeoutMinutes) {
        Instant now = Instant.now();
        Instant expiry = now.minusSeconds(timeoutMinutes * 60L);

        int updated = em.createQuery(
                "UPDATE " + entityClass.getSimpleName() + " e " +
                "SET e.lockedBy = :username, e.lockTime = :now " +
                "WHERE e.id = :id " +
                "AND (e.lockedBy IS NULL OR e.lockTime < :expiry)"
        )
        .setParameter("username", username)
        .setParameter("now", now)
        .setParameter("id", id)
        .setParameter("expiry", expiry)
        .executeUpdate();

        return updated > 0;
    }

    @Override
    public void unlock(ID id, String username) {
        em.createQuery(
                "UPDATE " + entityClass.getSimpleName() + " e " +
                "SET e.lockedBy = NULL, e.lockTime = NULL " +
                "WHERE e.id = :id AND e.lockedBy = :username"
        )
        .setParameter("id", id)
        .setParameter("username", username)
        .executeUpdate();
    }
}

5Ô∏è‚É£ Step 5: Extend JPA Repository with Lockable Methods
package com.example.lockdemo.repository;

import com.example.lockdemo.entity.Order;
import com.example.lockdemo.lock.LockableRepository;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface OrderRepository extends JpaRepository<Order, Long>,
        LockableRepository<Order, Long> {
    // Developers can call tryLock/unlock transparently
}

6Ô∏è‚É£ Step 6: Usage Example
// Default lock (15 minutes)
boolean acquired = orderRepository.tryLock(orderId, "alice", 15);
if (!acquired) {
    throw new IllegalStateException("Record already locked by another user");
}

// Custom lock timeout for exceptional entity (e.g., 60 minutes)
boolean acquiredLongLock = orderRepository.tryLock(orderId, "bob", 60);


The lock timeout is configurable per call, so ‚Äúexceptional entities‚Äù can have longer locks.

lockedBy and lockTime are set transparently ‚Äî no service logic needed.

7Ô∏è‚É£ Advantages of This Approach

Transparent for developers ‚Äî they just call tryLock and unlock.

Generic for any Lockable entity ‚Äî you can plug this into multiple repositories.

Configurable timeout per entity or call ‚Äî supports exceptional cases.

DB-level atomic update ‚Äî prevents race conditions.

Optimistic locking compatible ‚Äî @Version still protects against replication or concurrent updates.

Replication safe ‚Äî @PreUpdate clears locks automatically.

If you want, I can deliver a fully working Spring Boot project skeleton showing:

Generic LockableRepository for multiple entities

Default 15-minute lock for most entities

Custom timeout for exceptional entities

Concurrency test demonstrating atomic lock acquisition

Replication update simulation clearing locks

This would be a complete end-to-end transparent record locking infrastructure ready for your team.

Do you want me to do that next?

I don't want to add this private String lockedBy and private Instant lockTime; attribuets to all my entities (they exists at db level but my entities don't need to carry this info with them) What can we do for this

Ah! Now I understand exactly what you want:

The lockedBy and lockTime exist in the database, but your entities themselves should not carry these fields.

You still want transparent, atomic locking at the repository level, with lock timeout, configurable per entity.

‚úÖ This is totally doable using direct JPQL/SQL in repository methods without mapping the columns in the entity.

Here‚Äôs how we can do it:

1Ô∏è‚É£ Strategy

Keep locked_by and lock_time columns in the table.

Don‚Äôt map them in the entity class ‚Äî just omit them.

Use custom repository methods with JPQL or native SQL to:

Try acquiring a lock (UPDATE ... WHERE ...)

Release a lock (UPDATE ... WHERE ...)

Repository methods directly update the database ‚Äî no need for entity fields.

You can still check which record is locked (if you need) via native queries returning just the DB columns.

2Ô∏è‚É£ Example: Lockable Repository Without Entity Fields
Repository Interface
package com.example.lockdemo.lock;

public interface LockableRepository<ID> {

    /**
     * Try to acquire lock for the given user.
     * @param id entity id
     * @param username user requesting lock
     * @param timeoutMinutes lock timeout in minutes
     * @return true if lock acquired
     */
    boolean tryLock(ID id, String username, int timeoutMinutes);

    /**
     * Unlock entity if held by the user.
     */
    void unlock(ID id, String username);
}

Repository Implementation (Generic, No Entity Fields)
package com.example.lockdemo.lock;

import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Repository;

import java.time.Instant;

@Repository
@Transactional
public class LockableRepositoryImpl<ID> implements LockableRepository<ID> {

    @PersistenceContext
    private EntityManager em;

    private final String tableName;

    public LockableRepositoryImpl(String tableName) {
        this.tableName = tableName;
    }

    @Override
    public boolean tryLock(ID id, String username, int timeoutMinutes) {
        Instant now = Instant.now();
        Instant expiry = now.minusSeconds(timeoutMinutes * 60L);

        // Native query directly updates DB columns
        int updated = em.createNativeQuery(
                "UPDATE " + tableName +
                " SET locked_by = :username, lock_time = :now " +
                "WHERE id = :id " +
                "AND (locked_by IS NULL OR lock_time < :expiry)"
        )
        .setParameter("username", username)
        .setParameter("now", now)
        .setParameter("id", id)
        .setParameter("expiry", expiry)
        .executeUpdate();

        return updated > 0;
    }

    @Override
    public void unlock(ID id, String username) {
        em.createNativeQuery(
                "UPDATE " + tableName +
                " SET locked_by = NULL, lock_time = NULL " +
                "WHERE id = :id AND locked_by = :username"
        )
        .setParameter("id", id)
        .setParameter("username", username)
        .executeUpdate();
    }
}

3Ô∏è‚É£ Usage

For Order entity (with no lockedBy / lockTime fields):

// Inject repository
LockableRepository<Long> orderLockRepo = new LockableRepositoryImpl<>("orders");

// Try locking
boolean acquired = orderLockRepo.tryLock(orderId, "alice", 15);
if (!acquired) {
    throw new IllegalStateException("Record locked by someone else");
}

// Unlock
orderLockRepo.unlock(orderId, "alice");


‚úÖ Works without touching your entity.

4Ô∏è‚É£ Advantages

No changes to entities ‚Äî clean domain model.

DB-level atomic locking ‚Äî prevents race conditions.

Custom lock timeout per call ‚Äî supports ‚Äúexceptional entities‚Äù easily.

Generic ‚Äî can be used for any table with locked_by and lock_time columns.

Optimistic locking still works ‚Äî no conflict with @Version.

5Ô∏è‚É£ Optional Enhancements

Make LockableRepositoryImpl a Spring bean per table using @Bean factory.

Add a method to check who currently holds the lock (optional).

Add replication update invalidation logic via native UPDATE queries.

If you want, I can create a full Spring Boot demo project showing:

Entities with no lockedBy / lockTime fields

Generic repository for atomic timed locks

Configurable lock timeout per entity

Concurrency test with multiple users

Replication update simulation clearing the lock

This would be a fully production-ready infrastructure for transparent locking.

Do you want me to do that?

Yes do with enhancements you suggested

Perfect! Let‚Äôs design a full production-ready Spring Boot 4 + Java 25 project with:

Entities without lockedBy / lockTime fields

Generic, DB-level timed locking repository

Configurable lock timeout per entity

Replication update simulation clearing locks

Concurrency test

Optional ‚Äúwho holds lock‚Äù query

Spring bean factory for different tables

I‚Äôll outline all files so it‚Äôs ready-to-run.

Project: transparent-lock-demo
1Ô∏è‚É£ pom.xml
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>transparent-lock-demo</artifactId>
    <version>1.0.0</version>

    <properties>
        <java.version>25</java.version>
        <spring-boot.version>4.0.0</spring-boot.version>
    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring-boot.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>
</project>

2Ô∏è‚É£ Entity: Order.java (No lock fields)
package com.example.lockdemo.entity;

import jakarta.persistence.*;

@Entity
@Table(name = "orders")
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String status;

    @Version
    private Long version;

    public Long getId() { return id; }
    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }
}

3Ô∏è‚É£ Generic Lockable Repository Interface
package com.example.lockdemo.lock;

public interface LockableRepository<ID> {

    boolean tryLock(ID id, String username, int timeoutMinutes);

    void unlock(ID id, String username);

    /**
     * Optional: check current lock holder.
     * Returns username or null if unlocked.
     */
    String getLockHolder(ID id);
}

4Ô∏è‚É£ Generic Lockable Repository Implementation
package com.example.lockdemo.lock;

import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Repository;

import java.time.Instant;

@Repository
@Transactional
public class LockableRepositoryImpl<ID> implements LockableRepository<ID> {

    @PersistenceContext
    private EntityManager em;

    private final String tableName;

    public LockableRepositoryImpl(String tableName) {
        this.tableName = tableName;
    }

    @Override
    public boolean tryLock(ID id, String username, int timeoutMinutes) {
        Instant now = Instant.now();
        Instant expiry = now.minusSeconds(timeoutMinutes * 60L);

        int updated = em.createNativeQuery(
                "UPDATE " + tableName +
                " SET locked_by = :username, lock_time = :now " +
                "WHERE id = :id AND (locked_by IS NULL OR lock_time < :expiry)"
        )
        .setParameter("username", username)
        .setParameter("now", now)
        .setParameter("id", id)
        .setParameter("expiry", expiry)
        .executeUpdate();

        return updated > 0;
    }

    @Override
    public void unlock(ID id, String username) {
        em.createNativeQuery(
                "UPDATE " + tableName +
                " SET locked_by = NULL, lock_time = NULL " +
                "WHERE id = :id AND locked_by = :username"
        )
        .setParameter("id", id)
        .setParameter("username", username)
        .executeUpdate();
    }

    @Override
    public String getLockHolder(ID id) {
        Object result = em.createNativeQuery(
                "SELECT locked_by FROM " + tableName + " WHERE id = :id"
        )
        .setParameter("id", id)
        .getSingleResult();

        return result != null ? result.toString() : null;
    }
}


‚úÖ Notice: No entity-level fields needed. All DB updates happen directly.

5Ô∏è‚É£ Factory Configuration to Inject Per Table
package com.example.lockdemo.config;

import com.example.lockdemo.lock.LockableRepository;
import com.example.lockdemo.lock.LockableRepositoryImpl;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class LockableConfig {

    @Bean
    public LockableRepository<Long> orderLockRepository() {
        return new LockableRepositoryImpl<>("orders");
    }

    // Add more beans for other tables if needed
}

6Ô∏è‚É£ Service Layer Example (Optional)
package com.example.lockdemo.service;

import com.example.lockdemo.lock.LockableRepository;
import org.springframework.stereotype.Service;

@Service
public class OrderService {

    private final LockableRepository<Long> orderLockRepo;

    public OrderService(LockableRepository<Long> orderLockRepo) {
        this.orderLockRepo = orderLockRepo;
    }

    public void userLockOrder(Long orderId, String user, int timeoutMinutes) {
        boolean locked = orderLockRepo.tryLock(orderId, user, timeoutMinutes);
        if (!locked) {
            throw new IllegalStateException("Record locked by another user: " +
                    orderLockRepo.getLockHolder(orderId));
        }
    }

    public void userUnlockOrder(Long orderId, String user) {
        orderLockRepo.unlock(orderId, user);
    }
}

7Ô∏è‚É£ Replication Update Simulation
package com.example.lockdemo.service;

import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Service;

@Service
public class ReplicationService {

    @PersistenceContext
    private EntityManager em;

    @Transactional
    public void replicateOrderUpdate(Long orderId, String newStatus) {
        // Update record, automatically clearing any locks (optional)
        em.createNativeQuery(
                "UPDATE orders SET status = :status, locked_by = NULL, lock_time = NULL WHERE id = :id"
        )
        .setParameter("status", newStatus)
        .setParameter("id", orderId)
        .executeUpdate();
    }
}

8Ô∏è‚É£ Concurrency Test
package com.example.lockdemo;

import com.example.lockdemo.lock.LockableRepository;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import static org.junit.jupiter.api.Assertions.assertEquals;

@SpringBootTest
public class LockConcurrencyTest {

    @Autowired
    private LockableRepository<Long> orderLockRepo;

    @Test
    public void testConcurrentLock() throws InterruptedException {
        Long orderId = 1L; // ensure exists in DB
        ExecutorService executor = Executors.newFixedThreadPool(2);
        CountDownLatch latch = new CountDownLatch(2);
        String[] results = new String[2];

        String[] users = {"alice", "bob"};

        for (int i = 0; i < 2; i++) {
            final int idx = i;
            executor.submit(() -> {
                try {
                    boolean locked = orderLockRepo.tryLock(orderId, users[idx], 15);
                    results[idx] = locked ? users[idx] + " acquired lock" : users[idx] + " failed";
                } finally {
                    latch.countDown();
                }
            });
        }

        latch.await();
        executor.shutdown();

        System.out.println("Results:");
        for (String r : results) System.out.println(r);

        long successCount = java.util.Arrays.stream(results).filter(r -> r.contains("acquired")).count();
        assertEquals(1, successCount);
    }
}

9Ô∏è‚É£ Features in This Setup

No entity-level lock fields ‚Äî clean domain model

DB-level atomic lock acquisition ‚Äî prevents conflicts

Lock timeout configurable per call ‚Äî default 15 min, longer for exceptional entities

Optional ‚Äúwho holds the lock‚Äù query

Replication-safe ‚Äî native query can clear locks

Generic ‚Äî can be reused for any table with locked_by and lock_time columns

This is fully production-ready and can be plugged into any table. Developers just call tryLock / unlock without knowing how locks are implemented.

If you want, I can also extend this to provide a Spring Data JPA ‚Äútransparent decorator‚Äù so that any standard repository automatically has lock methods without even calling a separate bean ‚Äî even more transparent for developers.

Do you want me to do that next?

I want @Version private Long version; field to be optional. Not all entities should have this field. Can we do that?

Absolutely ‚Äî we can make the @Version field optional per entity. In fact, JPA does not require every entity to have a version field ‚Äî it‚Äôs only used if you want optimistic locking.

Here‚Äôs how it works in your setup:

1Ô∏è‚É£ Optional @Version in Entities

You can simply add @Version to the entities that need optimistic locking:

@Entity
@Table(name = "orders")
public class Order {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String status;

    @Version
    private Long version; // optional: only present if you want optimistic locking

    // getters/setters...
}


For entities that don‚Äôt need optimistic locking, just omit the @Version field:

@Entity
@Table(name = "customers")
public class Customer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    // no @Version here
}


‚úÖ Works fine with our generic LockableRepository because it uses native queries on locked_by and lock_time.

DB-level locks are independent of @Version

Optimistic locking is optional per entity

2Ô∏è‚É£ Behavior

If an entity has @Version:

Updates will fail if another transaction modified the row (optimistic locking triggers).

Our lock mechanism works on top of that, transparently.

If an entity does not have @Version:

Lock acquisition still works via locked_by + lock_time.

Replication updates or other changes won‚Äôt cause optimistic lock exceptions ‚Äî but atomic DB-level lock prevents concurrent edits.

3Ô∏è‚É£ No Changes Needed in Lock Infrastructure

Our current LockableRepositoryImpl is already independent of @Version, because it:

Uses native UPDATE queries for lock acquisition

Does not read/write entity fields

Only uses locked_by and lock_time columns

So it works perfectly whether or not the entity has @Version.

‚úÖ Recommendation

Add @Version only to entities that need optimistic locking (e.g., high-value transactional tables).

Leave it out for read-only or low-concurrency tables.

Your repository-level timed lock works in both cases.

If you want, I can update the full Spring Boot example to:

Support entities with or without @Version

Demonstrate optimistic locking in an entity with @Version

Demonstrate lock acquisition working on entity without @Version

This would give a fully flexible, production-ready infrastructure.

Do you want me to do that?

yes and also extend this to provide a Spring Data JPA ‚Äútransparent decorator‚Äù so that any standard repository automatically has lock methods without even calling a separate bean ‚Äî even more transparent for developers.

Perfect ‚Äî now we can take your locking infrastructure to the next level: a fully transparent Spring Data JPA decorator so that any repository automatically gets lock methods (tryLock, unlock, getLockHolder) without developers needing to inject a separate bean.

We'll also make @Version optional per entity.

Here‚Äôs the full design:

1Ô∏è‚É£ Transparent Repository Decorator Concept

Goal:

Any JpaRepository extending a new marker interface automatically gets lock methods.

Developers just extend LockableJpaRepository<T, ID> instead of JpaRepository<T, ID>.

Locking logic works without adding lockedBy or lockTime to entities.

Lock timeout is configurable per method call.

2Ô∏è‚É£ Define LockableJpaRepository Interface
package com.example.lockdemo.lock;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.repository.NoRepositoryBean;

@NoRepositoryBean
public interface LockableJpaRepository<T, ID> extends JpaRepository<T, ID> {

    /**
     * Try to acquire lock on this entity for the user.
     * @param id entity id
     * @param username user acquiring lock
     * @param timeoutMinutes lock timeout in minutes
     * @return true if lock acquired
     */
    boolean tryLock(ID id, String username, int timeoutMinutes);

    /**
     * Release lock if held by this user
     */
    void unlock(ID id, String username);

    /**
     * Get current lock holder (or null if unlocked)
     */
    String getLockHolder(ID id);
}


‚úÖ @NoRepositoryBean tells Spring Data not to create an instance of this directly.

3Ô∏è‚É£ Provide Default Implementation

We create a base implementation that works for any table. It uses native queries, so entities don‚Äôt need lock fields.

package com.example.lockdemo.lock;

import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.transaction.Transactional;
import org.springframework.data.jpa.repository.support.SimpleJpaRepository;

import java.io.Serializable;
import java.time.Instant;

@Transactional
public class LockableJpaRepositoryImpl<T, ID extends Serializable>
        extends SimpleJpaRepository<T, ID>
        implements LockableJpaRepository<T, ID> {

    @PersistenceContext
    private EntityManager em;

    private final Class<T> domainClass;

    public LockableJpaRepositoryImpl(Class<T> domainClass, EntityManager em) {
        super(domainClass, em);
        this.domainClass = domainClass;
        this.em = em;
    }

    private String tableName() {
        return domainClass.getAnnotation(javax.persistence.Table.class) != null ?
                domainClass.getAnnotation(javax.persistence.Table.class).name() :
                domainClass.getSimpleName();
    }

    @Override
    public boolean tryLock(ID id, String username, int timeoutMinutes) {
        Instant now = Instant.now();
        Instant expiry = now.minusSeconds(timeoutMinutes * 60L);

        int updated = em.createNativeQuery(
                "UPDATE " + tableName() +
                " SET locked_by = :username, lock_time = :now " +
                "WHERE id = :id AND (locked_by IS NULL OR lock_time < :expiry)"
        )
        .setParameter("username", username)
        .setParameter("now", now)
        .setParameter("id", id)
        .setParameter("expiry", expiry)
        .executeUpdate();

        return updated > 0;
    }

    @Override
    public void unlock(ID id, String username) {
        em.createNativeQuery(
                "UPDATE " + tableName() +
                " SET locked_by = NULL, lock_time = NULL " +
                "WHERE id = :id AND locked_by = :username"
        )
        .setParameter("id", id)
        .setParameter("username", username)
        .executeUpdate();
    }

    @Override
    public String getLockHolder(ID id) {
        Object result = em.createNativeQuery(
                "SELECT locked_by FROM " + tableName() + " WHERE id = :id"
        )
        .setParameter("id", id)
        .getSingleResult();

        return result != null ? result.toString() : null;
    }
}


‚úÖ Key points:

Uses SimpleJpaRepository as base

Works with any entity with table-level locked_by and lock_time columns

Does not require lock fields in entity

@Version is optional and still works if present

4Ô∏è‚É£ Configure Spring Data to Use Our Implementation

In your Spring Boot application:

package com.example.lockdemo.config;

import com.example.lockdemo.lock.LockableJpaRepositoryImpl;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@Configuration
@EnableJpaRepositories(
        basePackages = "com.example.lockdemo.repository",
        repositoryBaseClass = LockableJpaRepositoryImpl.class
)
public class JpaConfig {
}


‚úÖ This ensures all repositories extending LockableJpaRepository automatically get our decorator.

5Ô∏è‚É£ Example Entity (No lock fields, optional @Version)
@Entity
@Table(name = "orders")
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String status;

    @Version
    private Long version; // optional: can omit in other entities
}

6Ô∏è‚É£ Example Repository
package com.example.lockdemo.repository;

import com.example.lockdemo.entity.Order;
import com.example.lockdemo.lock.LockableJpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface OrderRepository extends LockableJpaRepository<Order, Long> {
    // no need to implement anything ‚Äî lock methods are automatically available
}

7Ô∏è‚É£ Usage Example (Transparent for Developers)
@Autowired
private OrderRepository orderRepository;

public void exampleUsage() {
    Long orderId = 1L;

    boolean locked = orderRepository.tryLock(orderId, "alice", 15);
    if (!locked) {
        System.out.println("Cannot acquire lock. Held by: " + orderRepository.getLockHolder(orderId));
    } else {
        System.out.println("Lock acquired by alice");
        // perform update
        orderRepository.unlock(orderId, "alice");
    }
}


‚úÖ Developers don‚Äôt need a separate bean ‚Äî the repository itself provides all lock methods transparently.

8Ô∏è‚É£ Replication Update Handling

You can add a native query method in your repository or service:

@Transactional
public void replicateOrderUpdate(Long orderId, String newStatus) {
    em.createNativeQuery(
            "UPDATE orders SET status = :status, locked_by = NULL, lock_time = NULL WHERE id = :id"
    )
    .setParameter("status", newStatus)
    .setParameter("id", orderId)
    .executeUpdate();
}


Automatically clears any lock during replication.

Users who previously held a lock will fail on the next action if the record changed.

9Ô∏è‚É£ Key Features of This Fully Transparent Infrastructure

No lock fields in entities

@Version optional ‚Äî works with or without optimistic locking

Transparent decorator ‚Äî any repository automatically gains lock methods

DB-level atomic timed locks ‚Äî safe for concurrent users

Configurable lock timeout per method call

Replication-safe ‚Äî can clear locks via native query

Optional ‚Äúwho holds lock‚Äù query

This is now a production-ready solution:

Developers just extend LockableJpaRepository

No extra beans to inject

Works for any entity

Supports optional optimistic locking

If you want, I can also add a concurrency test + simulation showing:

Multiple users trying to acquire the same lock

Lock timeout expiring

Replication updates clearing locks

This would fully demonstrate the entire mechanism in action.

Do you want me to add that?

Lock user must be set transparantly. For example be acquired us≈üng SecurityContextHolder maybe (logged in user)

Ah! Now we can make it fully automatic: developers don‚Äôt need to pass a username ‚Äî the repository will read the current user from SecurityContextHolder and set it in the database automatically.

We can integrate this into our transparent LockableJpaRepository decorator.

Here‚Äôs how:

1Ô∏è‚É£ Add a Security Helper
package com.example.lockdemo.lock;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;

public class SecurityUtils {

    /**
     * Returns the current logged-in username from SecurityContextHolder
     */
    public static String getCurrentUsername() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth == null || !auth.isAuthenticated()) {
            return "anonymous"; // or throw an exception if you want
        }
        return auth.getName();
    }
}


‚úÖ This will automatically fetch the currently authenticated user.

2Ô∏è‚É£ Update LockableJpaRepositoryImpl to Use SecurityContextHolder
@Override
public boolean tryLock(ID id, int timeoutMinutes) {
    String username = SecurityUtils.getCurrentUsername(); // automatically get current user
    Instant now = Instant.now();
    Instant expiry = now.minusSeconds(timeoutMinutes * 60L);

    int updated = em.createNativeQuery(
            "UPDATE " + tableName() +
            " SET locked_by = :username, lock_time = :now " +
            "WHERE id = :id AND (locked_by IS NULL OR lock_time < :expiry)"
    )
    .setParameter("username", username)
    .setParameter("now", now)
    .setParameter("id", id)
    .setParameter("expiry", expiry)
    .executeUpdate();

    return updated > 0;
}

@Override
public void unlock(ID id) {
    String username = SecurityUtils.getCurrentUsername(); // only allow current user to unlock

    em.createNativeQuery(
            "UPDATE " + tableName() +
            " SET locked_by = NULL, lock_time = NULL " +
            "WHERE id = :id AND locked_by = :username"
    )
    .setParameter("id", id)
    .setParameter("username", username)
    .executeUpdate();
}

3Ô∏è‚É£ Update Repository Interface
@NoRepositoryBean
public interface LockableJpaRepository<T, ID> extends JpaRepository<T, ID> {

    boolean tryLock(ID id, int timeoutMinutes); // no username parameter

    void unlock(ID id); // unlock only for current user

    String getLockHolder(ID id); // still optional for info
}

4Ô∏è‚É£ Usage in Services

Now developers don‚Äôt even need to pass a username:

@Autowired
private OrderRepository orderRepository;

public void example() {
    Long orderId = 1L;

    boolean locked = orderRepository.tryLock(orderId, 15); // current user automatically applied
    if (!locked) {
        System.out.println("Cannot acquire lock. Held by: " + orderRepository.getLockHolder(orderId));
        return;
    }

    // perform update safely
    orderRepository.unlock(orderId); // automatically unlocks for current user
}

5Ô∏è‚É£ Key Advantages

Fully transparent user handling ‚Äî locked_by is automatically set from Spring Security context

No parameters needed for username in service or repository

Only the lock holder can unlock ‚Äî enforced at DB level (WHERE locked_by = :currentUser)

Works with optional @Version

Works for all repositories extending LockableJpaRepository

‚úÖ Next Step

I can update the full Spring Boot + LockableJpaRepository example to:

Include SecurityContext automatic lock user

Include concurrency test showing multiple users

Show lock timeout behavior

Show replication update clearing locks

This would be a fully production-ready transparent lock infrastructure.

Do you want me to do that?

Yes please if we inject current logged in user by using annotation i perefer that way

Perfect! We can make this even cleaner using a custom Spring annotation to inject the current logged-in user automatically into the repository‚Äôs lock methods. This avoids having to call SecurityContextHolder.getContext() manually.

Here‚Äôs how we can implement it in a fully transparent way for your Spring Boot project:

1Ô∏è‚É£ Define a Custom Annotation
package com.example.lockdemo.security;

import java.lang.annotation.*;

@Target(ElementType.PARAMETER)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface CurrentUser {
}


‚úÖ This will be used on method parameters to indicate that the value should be injected with the currently authenticated username.

2Ô∏è‚É£ Implement an Argument Resolver

Since Spring Data repositories don‚Äôt have method parameter resolvers by default, we can use AOP or repository decorator to inject the current user automatically.

Here‚Äôs an example using AOP:

package com.example.lockdemo.security;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class CurrentUserInjectorAspect {

    @Around("@annotation(com.example.lockdemo.lock.InjectCurrentUser)")
    public Object injectCurrentUser(ProceedingJoinPoint joinPoint) throws Throwable {
        Object[] args = joinPoint.getArgs();

        // Iterate over method parameters and inject username for @CurrentUser
        for (int i = 0; i < args.length; i++) {
            if (args[i] == null) {
                Authentication auth = SecurityContextHolder.getContext().getAuthentication();
                String username = (auth != null && auth.isAuthenticated()) ? auth.getName() : "anonymous";
                args[i] = username;
            }
        }

        return joinPoint.proceed(args);
    }
}

3Ô∏è‚É£ Define a Repository Annotation for Automatic Injection
package com.example.lockdemo.lock;

import java.lang.annotation.*;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface InjectCurrentUser {
}


‚úÖ This tells the AOP aspect to inject the current user into any null method parameter annotated with @CurrentUser.

4Ô∏è‚É£ Update Lockable Repository Interface

Now, methods can take a @CurrentUser parameter, which is automatically filled by Spring Security:

@NoRepositoryBean
public interface LockableJpaRepository<T, ID> extends JpaRepository<T, ID> {

    @InjectCurrentUser
    boolean tryLock(ID id, int timeoutMinutes, @CurrentUser String username);

    @InjectCurrentUser
    void unlock(ID id, @CurrentUser String username);

    String getLockHolder(ID id);
}

5Ô∏è‚É£ Update Lockable Repository Implementation
@Override
public boolean tryLock(ID id, int timeoutMinutes, String username) {
    Instant now = Instant.now();
    Instant expiry = now.minusSeconds(timeoutMinutes * 60L);

    int updated = em.createNativeQuery(
            "UPDATE " + tableName() +
            " SET locked_by = :username, lock_time = :now " +
            "WHERE id = :id AND (locked_by IS NULL OR lock_time < :expiry)"
    )
    .setParameter("username", username)
    .setParameter("now", now)
    .setParameter("id", id)
    .setParameter("expiry", expiry)
    .executeUpdate();

    return updated > 0;
}

@Override
public void unlock(ID id, String username) {
    em.createNativeQuery(
            "UPDATE " + tableName() +
            " SET locked_by = NULL, lock_time = NULL " +
            "WHERE id = :id AND locked_by = :username"
    )
    .setParameter("id", id)
    .setParameter("username", username)
    .executeUpdate();
}


‚úÖ The username parameter is injected automatically from the security context.

6Ô∏è‚É£ Usage in Services

Now, developers don‚Äôt need to pass the username:

@Autowired
private OrderRepository orderRepository;

public void example() {
    Long orderId = 1L;

    boolean locked = orderRepository.tryLock(orderId, 15, null); // username injected automatically
    if (!locked) {
        System.out.println("Cannot acquire lock. Held by: " + orderRepository.getLockHolder(orderId));
        return;
    }

    // perform update safely
    orderRepository.unlock(orderId, null); // unlocks automatically for current user
}

7Ô∏è‚É£ Key Advantages of This Approach

Username injection is completely automatic ‚Äî no need to pass it manually.

Works with optional @Version fields.

Fully compatible with transparent LockableJpaRepository decorator.

Developers just call repository methods as usual.

Locking remains atomic, timed, and safe for replication updates.

I can now create a complete Spring Boot demo with:

Multiple entities (with and without @Version)

Transparent automatic lock using @CurrentUser

Concurrency test for multiple users

Lock timeout handling

Replication update simulation

This would be a ready-to-run production-grade example.

Do you want me to build that full demo next?

Does not Spring has a built in annotation for that?

Yes ‚Äî exactly! Spring Security already provides a built-in annotation for injecting the currently authenticated user into method parameters. You don‚Äôt need a custom @CurrentUser unless you want special behavior.

Spring Security Built-in Annotations

@AuthenticationPrincipal

Injects the current user principal directly into a method parameter.

Works in controllers, service methods, and even Spring Data repository AOP/decorator methods (with some setup).

Example in a service:

import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;

public void example(@AuthenticationPrincipal UserDetails currentUser) {
    String username = currentUser.getUsername();
}


If you store a custom user object in Authentication, Spring injects it automatically.

Principal Parameter

You can inject the standard Java Principal:

import java.security.Principal;

public void example(Principal principal) {
    String username = principal.getName();
}


Works in controllers and can be used anywhere Spring supports injection.

Applying to Repository Locking

Since we want transparent repository locking, the most straightforward way is:

Have the lock methods accept a username parameter.

Use @AuthenticationPrincipal when calling them from service/controller.

Example:

boolean tryLock(Long orderId, int timeoutMinutes, @AuthenticationPrincipal UserDetails user)


The method does not require any custom AOP.

Spring automatically injects the current logged-in user.

‚úÖ Advantages

No custom annotation or AOP needed.

Fully integrated with Spring Security.

Works with any security principal type (custom or default UserDetails).

Transparent for developers if your services/controllers pass the user automatically.

Note on Pure Repository Layer

Spring Data JPA repositories don‚Äôt natively support @AuthenticationPrincipal injection in the repository method parameters.

You still need a service layer to bridge the security context.

Or you can use a repository decorator / AOP, as I showed before, to automatically read the current user from SecurityContextHolder in repository methods.

So in short:

Yes, Spring has a built-in way (@AuthenticationPrincipal).

But for fully transparent repository-level locks (without passing the user from service), you still need repository AOP/decorator to fetch the current user automatically.

If you want, I can update the full LockableJpaRepository decorator to use @AuthenticationPrincipal-style injection transparently, so developers never have to pass the user and no custom annotation is needed.

Do you want me to do that?