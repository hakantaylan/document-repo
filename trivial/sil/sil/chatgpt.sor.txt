---------------------------------------------------------------------------
PART A ‚Äî Debug repository instantiation (step-by-step)

We‚Äôll trace exactly how Spring Data JPA creates a repository and where your code is invoked.

A1Ô∏è‚É£ Enable the right debug logs

Add this to application.yml:

logging:
  level:
    org.springframework.data.repository.config: TRACE
    org.springframework.data.jpa.repository.support: TRACE
    org.springframework.beans.factory.support: DEBUG


What this gives you:

repository scanning

factory selection

base-class resolution

proxy creation

A2Ô∏è‚É£ Repository scanning phase

Spring Boot does:

AutoConfiguration ‚Üí @EnableJpaRepositories


Look for log lines like:

Scanning for JPA repositories in packages com.example.repo.poc.repository.custom


üí° If your repository is not listed here ‚Üí it will never use your factory

A3Ô∏è‚É£ FactoryBean selection (CRITICAL)

Spring chooses the FactoryBean before anything else.

Expected log:

Creating JPA repository factory for PersonRepository
Using repositoryFactoryBeanClass: ConditionalRepositoryFactoryBean


If you see instead:

JpaRepositoryFactoryBean


then:

wrong package

auto-config not picked up

starter not loaded

üëâ This step decides everything

A4Ô∏è‚É£ Factory creation

Add a breakpoint or log:

@Override
protected RepositoryFactorySupport createRepositoryFactory(EntityManager em) {
    log.info(">>> Creating ConditionalRepositoryFactory");
    return new ConditionalRepositoryFactory(em, publisher);
}


You should see:

>>> Creating ConditionalRepositoryFactory


If not ‚Üí your FactoryBean is not in play.

A5Ô∏è‚É£ Base class resolution

Spring calls this first:

getRepositoryBaseClass(RepositoryMetadata metadata)


Add:

log.info(
    ">>> Resolving base class for {}",
    metadata.getRepositoryInterface().getName()
);


Then domain-level logs:

>>> Resolving base class for PersonRepository
>>> Selected EmptySpecOutboxRepositoryImpl


This decides:

proxy type

method lookup strategy

A6Ô∏è‚É£ Target repository instantiation

Then Spring calls:

getTargetRepository(RepositoryInformation, EntityManager)


Add:

log.info(
    ">>> Creating target repository for {}",
    information.getRepositoryInterface().getName()
);


Expected flow:

>>> Creating target repository for PersonRepository
>>> Instantiating EmptySpecOutboxRepositoryImpl


This is the actual concrete object behind the proxy.

A7Ô∏è‚É£ Proxy wrapping

Finally Spring creates:

JdkDynamicAopProxy / CglibAopProxy


This is why you see:

EmptySpecOutboxRepositoryImpl$$SpringCGLIB$$

A8Ô∏è‚É£ One-liner sanity check (runtime)
AopUtils.getTargetClass(personRepository)


If this returns your impl ‚Üí you‚Äôre golden.

PART B ‚Äî Turn this into a reusable Spring Boot Starter

This is how you ship it cleanly to other projects.

B1Ô∏è‚É£ Module structure
outbox-jpa-starter
‚îú‚îÄ‚îÄ outbox-jpa-core
‚îÇ   ‚îú‚îÄ‚îÄ BaseRepository
‚îÇ   ‚îú‚îÄ‚îÄ BaseRepositoryImpl
‚îÇ   ‚îú‚îÄ‚îÄ ConditionalRepositoryFactory
‚îÇ   ‚îî‚îÄ‚îÄ OutboxPublisher (SPI)
‚îÇ
‚îú‚îÄ‚îÄ outbox-jpa-autoconfigure
‚îÇ   ‚îú‚îÄ‚îÄ ConditionalJpaAutoConfiguration
‚îÇ   ‚îî‚îÄ‚îÄ ConditionalRepositoryFactoryBean
‚îÇ
‚îî‚îÄ‚îÄ outbox-jpa-starter
    ‚îî‚îÄ‚îÄ pom.xml (dependency-only)

B2Ô∏è‚É£ Auto-configuration module
ConditionalJpaAutoConfiguration
@AutoConfiguration
@ConditionalOnClass(JpaRepository.class)
@ConditionalOnBean(OutboxPublisher.class)
@EnableJpaRepositories(
    basePackages = "${outbox.jpa.base-packages}",
    repositoryFactoryBeanClass = ConditionalRepositoryFactoryBean.class
)
public class ConditionalJpaAutoConfiguration {
}

B3Ô∏è‚É£ spring.factories / AutoConfiguration imports
Spring Boot 3.x (recommended)
META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports

com.example.outbox.autoconfigure.ConditionalJpaAutoConfiguration

B4Ô∏è‚É£ Configuration properties (starter-friendly)
@ConfigurationProperties(prefix = "outbox.jpa")
public class OutboxJpaProperties {

    /**
     * Packages that opt-in to custom repositories
     */
    private List<String> basePackages = List.of();

    // getters / setters
}


Inject into auto-config:

@EnableJpaRepositories(
    basePackages = "#{@outboxJpaProperties.basePackages}",
    repositoryFactoryBeanClass = ConditionalRepositoryFactoryBean.class
)


‚úî No hard-coded packages
‚úî Starter is reusable
‚úî Consumer decides scope

B5Ô∏è‚É£ SPI for OutboxPublisher

In the starter, define only the interface:

public interface OutboxPublisher<T> {
    void publish(T entity);
}


In the application, provide the bean:

@Bean
public OutboxPublisher<Person> personOutboxPublisher() {
    return person -> { ... };
}


Auto-config triggers only if publisher exists.

B6Ô∏è‚É£ Safety defaults (VERY important)

Inside your factory:

if (!BaseRepository.class.isAssignableFrom(
        information.getRepositoryInterface())) {
    return super.getTargetRepository(information, em);
}


This guarantees:

no breaking changes

no accidental global override

B7Ô∏è‚É£ How users consume the starter
<dependency>
  <groupId>com.example</groupId>
  <artifactId>outbox-jpa-starter</artifactId>
</dependency>

outbox:
  jpa:
    base-packages:
      - com.myapp.repositories.outbox


Then:

public interface OrderRepository
        extends BaseRepository<Order, UUID> {
}


Boom üí• ‚Äî opt-in, zero config.

B8Ô∏è‚É£ Starter validation checklist

‚úî Works with multiple EMFs
‚úî Plays with Boot upgrades
‚úî No classpath side effects
‚úî Can be disabled by config
‚úî Safe-by-default
------------------------------------------------------------------------------------------------------------
Auto-configuration class (starter magic)
@AutoConfiguration
@ConditionalOnClass(JpaRepository.class)
@ConditionalOnBean(EntityManagerFactory.class)
@EnableJpaRepositories(
    basePackages = "${outbox.jpa.repositories-package:}",
    repositoryFactoryBeanClass = ConditionalRepositoryFactoryBean.class
)
public class OutboxJpaAutoConfiguration {
}

Why property-based package?

So consumers control opt-in without code changes.

C. application.yml (consumer side)
outbox:
  jpa:
    repositories-package: com.example.repo.custom


‚úî No accidental global override
‚úî Explicit opt-in
‚úî Starter-friendly

D. META-INF registration (Spring Boot 3+)

outbox-jpa-autoconfigure/src/main/resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports

com.example.outbox.autoconfigure.OutboxJpaAutoConfiguration


This is required

Provide sane defaults (publisher)
@Configuration
class OutboxDefaults {

    @Bean
    @ConditionalOnMissingBean
    OutboxPublisher<?> noopOutboxPublisher() {
        return entity -> {};
    }
}


Now your starter:

never fails startup

allows override

F. Starter POM (important bits)
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-autoconfigure</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.data</groupId>
    <artifactId>spring-data-jpa</artifactId>
</dependency>


üö´ NO spring-boot-starter-data-jpa
Starters must be thin

Runtime verification trick (simple & effective)
@Component
class RepoInspector {

    RepoInspector(ApplicationContext ctx) {
        ctx.getBeansOfType(Repository.class)
           .forEach((name, repo) ->
               System.out.println(name + " -> " + repo.getClass())
           );
    }
}


This prints every repository + actual backing class