I have a soft lock service and i use it in this way to prevent data consistency/staleness problem. First users gets soft lock an gets a fencing token.

Pseudocode
@Transactional
void update(id, token) {
    validateToken(id, token);
    mutateAggregate()
    repository.save(entity);    // flush at commit
}
This code is subject to tictou problem. How about making this. Does it prevents this problem

Pseudocode
@Transactional
void update(id, token) {
    validateToken(id, token); 
    mutateAggregate(); 
    repository.save(entity); 
UPDATE resource
SET name= name
WHERE id = ?
  AND fencing_token = ?
  AND lock_expires_at > now();
}
and checking returned value from last update script and if it is zero rollback transaction. By the way setting name = name means all modifications already done by calling repository.save(entity); 
I added last update script for a defence mechanism. Does this work?