What you want is composable, reusable Specifications that can:

Live in separate classes

Query deeply nested associations

Avoid duplicate joins when multiple specs are combined

This is a classic Spring Data JPA Specification problem, and it is solvable cleanly with a small infrastructure pattern.

Key ideas (important)

Always reuse joins via Root#getJoins()

Encapsulate join-creation logic

Specifications should only express predicates, not structure

Use LEFT joins unless filtering requires INNER

1. Create a reusable Join Helper (critical)

This helper ensures the same join is reused instead of recreated.

public final class JoinUtils {

    private JoinUtils() {}

    @SuppressWarnings("unchecked")
    public static <R, J> Join<R, J> getOrCreateJoin(
            From<?, R> root,
            String attribute,
            JoinType joinType
    ) {
        return root.getJoins().stream()
                .filter(j -> j.getAttribute().getName().equals(attribute))
                .map(j -> (Join<R, J>) j)
                .findFirst()
                .orElseGet(() -> root.join(attribute, joinType));
    }
}


This is the most important piece.

2. Specification per concern (one class per spec)
OrderSpecifications
public final class OrderSpecifications {

    private OrderSpecifications() {}

    public static Specification<Order> customerEquals(String customer) {
        return (root, query, cb) ->
                cb.equal(root.get("customer"), customer);
    }
}

3. Nested specs that reuse joins
OrderItemSpecifications
public final class OrderItemSpecifications {

    private OrderItemSpecifications() {}

    public static Specification<Order> hasProduct(String product) {
        return (root, query, cb) -> {
            Join<Order, OrderItem> items =
                    JoinUtils.getOrCreateJoin(root, "items", JoinType.LEFT);

            return cb.equal(items.get("product"), product);
        };
    }
}

ItemTagSpecifications
public final class ItemTagSpecifications {

    private ItemTagSpecifications() {}

    public static Specification<Order> hasTagName(String tagName) {
        return (root, query, cb) -> {
            Join<Order, OrderItem> items =
                    JoinUtils.getOrCreateJoin(root, "items", JoinType.LEFT);

            Join<OrderItem, ItemTag> tags =
                    JoinUtils.getOrCreateJoin(items, "tags", JoinType.LEFT);

            return cb.equal(tags.get("name"), tagName);
        };
    }
}

TagAttributeSpecifications (deep nesting)
public final class TagAttributeSpecifications {

    private TagAttributeSpecifications() {}

    public static Specification<Order> hasTagAttribute(String attributeName) {
        return (root, query, cb) -> {
            Join<Order, OrderItem> items =
                    JoinUtils.getOrCreateJoin(root, "items", JoinType.LEFT);

            Join<OrderItem, ItemTag> tags =
                    JoinUtils.getOrCreateJoin(items, "tags", JoinType.LEFT);

            Join<ItemTag, TagAttribute> attributes =
                    JoinUtils.getOrCreateJoin(tags, "attributes", JoinType.LEFT);

            return cb.equal(attributes.get("name"), attributeName);
        };
    }
}

4. Combine specs safely (no duplicate joins)
Specification<Order> spec =
        Specification.where(OrderSpecifications.customerEquals("John"))
                     .and(OrderItemSpecifications.hasProduct("Laptop"))
                     .and(ItemTagSpecifications.hasTagName("PROMO"))
                     .and(TagAttributeSpecifications.hasTagAttribute("COLOR"));


‚úî Joins are reused
‚úî No Cartesian explosion
‚úî Each spec is independent
‚úî Clean separation of responsibility

5. Important JPA details (don‚Äôt skip)
Avoid duplicate results

When joining collections, always add:

query.distinct(true);


You can do it in a base spec:

public static Specification<Order> distinct() {
    return (root, query, cb) -> {
        query.distinct(true);
        return cb.conjunction();
    };
}


Then:

Specification<Order> spec =
        Specification.where(OrderSpecifications.distinct())
                     .and(...);

6. Why this works
Problem	Solution
Duplicate joins	getOrCreateJoin()
Deep nesting	Layered specs
Reusability	One spec = one concern
Spring 4 compatible	Pure JPA Criteria
Java 25 ready	No deprecated APIs
7. Optional improvement (advanced)

If you want even cleaner specs, you can introduce a JoinContext object stored in CriteriaQuery#getHints() ‚Äî but the above approach is already production-grade and widely used.

Summary

‚úÖ Put each Specification in its own class
‚úÖ Use a shared Join utility
‚úÖ Reuse joins to avoid duplication
‚úÖ Combine specs freely
‚úÖ Works with deep nested relationships

If you want, I can also:

Refactor this to metamodel-based (static metamodel)

Show a generic recursive join builder

Add dynamic filter building from REST parameters

Just tell me.

Give me the optional improvement you sugested

Below is the optional / advanced improvement using a JoinContext stored in the CriteriaQuery so that:

Joins are created once per query

Specs do not depend on Root structure

You can reuse joins across all specifications, even deeply nested

This scales very well as your model grows

This is a professional-grade pattern used in large Spring Data JPA codebases.

Concept

We store a JoinContext inside the CriteriaQuery using query hints.

Each Specification:

Retrieves the context

Asks for a join path

Gets the same join instance every time

No duplicate joins. No tight coupling.

1. JoinContext
public class JoinContext {

    private final Map<String, From<?, ?>> joins = new HashMap<>();

    @SuppressWarnings("unchecked")
    public <F, T> Join<F, T> getOrCreate(
            From<?, F> from,
            String attribute,
            JoinType joinType
    ) {
        String key = from.getJavaType().getName() + "." + attribute;

        return (Join<F, T>) joins.computeIfAbsent(
                key,
                k -> from.join(attribute, joinType)
        );
    }
}

2. Query hint helper
public final class JoinContextHolder {

    private static final String JOIN_CONTEXT_KEY = "JOIN_CONTEXT";

    private JoinContextHolder() {}

    public static JoinContext get(CriteriaQuery<?> query) {
        return (JoinContext) query.getHints()
                .computeIfAbsent(JOIN_CONTEXT_KEY, k -> new JoinContext());
    }
}

3. Base specification (initializes the context)

You must add this spec once.

public final class BaseSpecifications {

    private BaseSpecifications() {}

    public static <T> Specification<T> withJoinContext() {
        return (root, query, cb) -> {
            JoinContextHolder.get(query);
            query.distinct(true);
            return cb.conjunction();
        };
    }
}

4. Deep specs using JoinContext
OrderItem spec
public final class OrderItemSpecifications {

    private OrderItemSpecifications() {}

    public static Specification<Order> hasProduct(String product) {
        return (root, query, cb) -> {
            JoinContext ctx = JoinContextHolder.get(query);

            Join<Order, OrderItem> items =
                    ctx.getOrCreate(root, "items", JoinType.LEFT);

            return cb.equal(items.get("product"), product);
        };
    }
}

ItemTag spec
public final class ItemTagSpecifications {

    private ItemTagSpecifications() {}

    public static Specification<Order> hasTag(String tagName) {
        return (root, query, cb) -> {
            JoinContext ctx = JoinContextHolder.get(query);

            Join<Order, OrderItem> items =
                    ctx.getOrCreate(root, "items", JoinType.LEFT);

            Join<OrderItem, ItemTag> tags =
                    ctx.getOrCreate(items, "tags", JoinType.LEFT);

            return cb.equal(tags.get("name"), tagName);
        };
    }
}

TagAttribute spec (very deep)
public final class TagAttributeSpecifications {

    private TagAttributeSpecifications() {}

    public static Specification<Order> hasAttribute(String attributeName) {
        return (root, query, cb) -> {
            JoinContext ctx = JoinContextHolder.get(query);

            Join<Order, OrderItem> items =
                    ctx.getOrCreate(root, "items", JoinType.LEFT);

            Join<OrderItem, ItemTag> tags =
                    ctx.getOrCreate(items, "tags", JoinType.LEFT);

            Join<ItemTag, TagAttribute> attributes =
                    ctx.getOrCreate(tags, "attributes", JoinType.LEFT);

            return cb.equal(attributes.get("name"), attributeName);
        };
    }
}

5. Usage
Specification<Order> spec =
        Specification.where(BaseSpecifications.withJoinContext())
                     .and(OrderSpecifications.customerEquals("John"))
                     .and(OrderItemSpecifications.hasProduct("Laptop"))
                     .and(ItemTagSpecifications.hasTag("PROMO"))
                     .and(TagAttributeSpecifications.hasAttribute("COLOR"));

List<Order> orders = orderRepository.findAll(spec);

6. Why this is better than the simple approach
Aspect	Simple JoinUtils	JoinContext
Join reuse	Root-level only	Whole query
Nested joins	Manual	Automatic
Spec independence	Medium	High
Large query safety	OK	Excellent
Maintenance	Simple	Slightly more code
7. Important notes
‚ö† Key uniqueness

We use:

from.getJavaType().getName() + "." + attribute


This avoids collisions when the same attribute name appears on different entities.

‚ö† INNER vs LEFT

If any spec requires INNER joins:

You must standardize join type OR

Promote LEFT ‚Üí INNER manually

For safety, many teams default to LEFT.

8. When to use this pattern

Use this JoinContext pattern when:

You have dynamic search APIs

Specs are composed arbitrarily

Entities are deeply nested

Duplicate joins have already bitten you üòÑ

Final takeaway

This turns your Specifications into:

Stateless

Composable

Order-independent

Join-safe

If you want, I can also:

Convert this to static metamodel (Order_)

Add path-expression specs

Show dynamic REST filter ‚Üí Specification mapping

Just say the word.

Add new attributes to the entities and make this composable set up like this? Sometimes i need to search by all attributes but sometimes i nedd to search by per one attribute of each entities. How can i achieve this without compromising composable structure

This is a very good question and it goes to the heart of why you build composable Specifications in the first place.

Below is a clean, scalable pattern that lets you:

‚úî Add new attributes freely
‚úî Search by any single attribute
‚úî Search by all attributes together
‚úî Keep each spec composable & reusable
‚úî Avoid ‚Äúgod specifications‚Äù
‚úî Avoid duplicate joins

This builds directly on the JoinContext pattern you already have.

1Ô∏è‚É£ Extend entities (example)

Let‚Äôs add a few realistic attributes.

@Entity
@Table(name = "orders")
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String customer;
    private LocalDate orderDate;
    private OrderStatus status;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<OrderItem> items = new HashSet<>();
}

@Entity
public class OrderItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String product;
    private BigDecimal price;
    private Integer quantity;

    @ManyToOne(fetch = FetchType.LAZY)
    private Order order;

    @OneToMany(mappedBy = "orderItem", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<ItemTag> tags = new HashSet<>();
}

@Entity
public class ItemTag {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String category;

    @ManyToOne(fetch = FetchType.LAZY)
    private OrderItem orderItem;

    @OneToMany(mappedBy = "itemTag", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<TagAttribute> attributes = new HashSet<>();
}

@Entity
public class TagAttribute {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String value;

    @ManyToOne(fetch = FetchType.LAZY)
    private ItemTag itemTag;
}

2Ô∏è‚É£ Rule: one attribute = one specification

This is the key principle.

Never create ‚Äúsearch-by-everything‚Äù specs.

3Ô∏è‚É£ Attribute-level specifications
Order attributes
public final class OrderSpecs {

    private OrderSpecs() {}

    public static Specification<Order> customerEquals(String customer) {
        return (root, query, cb) ->
                customer == null ? cb.conjunction()
                                 : cb.equal(root.get("customer"), customer);
    }

    public static Specification<Order> statusEquals(OrderStatus status) {
        return (root, query, cb) ->
                status == null ? cb.conjunction()
                               : cb.equal(root.get("status"), status);
    }

    public static Specification<Order> orderDateBetween(
            LocalDate from, LocalDate to) {

        return (root, query, cb) -> {
            if (from == null && to == null) {
                return cb.conjunction();
            }
            if (from != null && to != null) {
                return cb.between(root.get("orderDate"), from, to);
            }
            return from != null
                    ? cb.greaterThanOrEqualTo(root.get("orderDate"), from)
                    : cb.lessThanOrEqualTo(root.get("orderDate"), to);
        };
    }
}

OrderItem attributes
public final class OrderItemSpecs {

    private OrderItemSpecs() {}

    public static Specification<Order> productEquals(String product) {
        return (root, query, cb) -> {
            if (product == null) return cb.conjunction();

            JoinContext ctx = JoinContextHolder.get(query);
            Join<Order, OrderItem> items =
                    ctx.getOrCreate(root, "items", JoinType.LEFT);

            return cb.equal(items.get("product"), product);
        };
    }

    public static Specification<Order> priceBetween(
            BigDecimal min, BigDecimal max) {

        return (root, query, cb) -> {
            if (min == null && max == null) return cb.conjunction();

            JoinContext ctx = JoinContextHolder.get(query);
            Join<Order, OrderItem> items =
                    ctx.getOrCreate(root, "items", JoinType.LEFT);

            if (min != null && max != null) {
                return cb.between(items.get("price"), min, max);
            }
            return min != null
                    ? cb.greaterThanOrEqualTo(items.get("price"), min)
                    : cb.lessThanOrEqualTo(items.get("price"), max);
        };
    }
}

ItemTag attributes
public final class ItemTagSpecs {

    private ItemTagSpecs() {}

    public static Specification<Order> tagNameEquals(String name) {
        return (root, query, cb) -> {
            if (name == null) return cb.conjunction();

            JoinContext ctx = JoinContextHolder.get(query);

            Join<Order, OrderItem> items =
                    ctx.getOrCreate(root, "items", JoinType.LEFT);

            Join<OrderItem, ItemTag> tags =
                    ctx.getOrCreate(items, "tags", JoinType.LEFT);

            return cb.equal(tags.get("name"), name);
        };
    }

    public static Specification<Order> tagCategoryEquals(String category) {
        return (root, query, cb) -> {
            if (category == null) return cb.conjunction();

            JoinContext ctx = JoinContextHolder.get(query);

            Join<Order, OrderItem> items =
                    ctx.getOrCreate(root, "items", JoinType.LEFT);

            Join<OrderItem, ItemTag> tags =
                    ctx.getOrCreate(items, "tags", JoinType.LEFT);

            return cb.equal(tags.get("category"), category);
        };
    }
}

TagAttribute attributes
public final class TagAttributeSpecs {

    private TagAttributeSpecs() {}

    public static Specification<Order> attributeNameEquals(String name) {
        return (root, query, cb) -> {
            if (name == null) return cb.conjunction();

            JoinContext ctx = JoinContextHolder.get(query);

            Join<Order, OrderItem> items =
                    ctx.getOrCreate(root, "items", JoinType.LEFT);

            Join<OrderItem, ItemTag> tags =
                    ctx.getOrCreate(items, "tags", JoinType.LEFT);

            Join<ItemTag, TagAttribute> attrs =
                    ctx.getOrCreate(tags, "attributes", JoinType.LEFT);

            return cb.equal(attrs.get("name"), name);
        };
    }

    public static Specification<Order> attributeValueEquals(String value) {
        return (root, query, cb) -> {
            if (value == null) return cb.conjunction();

            JoinContext ctx = JoinContextHolder.get(query);

            Join<Order, OrderItem> items =
                    ctx.getOrCreate(root, "items", JoinType.LEFT);

            Join<OrderItem, ItemTag> tags =
                    ctx.getOrCreate(items, "tags", JoinType.LEFT);

            Join<ItemTag, TagAttribute> attrs =
                    ctx.getOrCreate(tags, "attributes", JoinType.LEFT);

            return cb.equal(attrs.get("value"), value);
        };
    }
}

4Ô∏è‚É£ Composing ‚Äúsearch by all‚Äù vs ‚Äúsearch by one‚Äù
Search by one attribute
Specification<Order> spec =
        Specification.where(BaseSpecifications.withJoinContext())
                     .and(OrderItemSpecs.productEquals("Laptop"));

Search by many attributes (all)
Specification<Order> spec =
        Specification.where(BaseSpecifications.withJoinContext())
                     .and(OrderSpecs.customerEquals("John"))
                     .and(OrderSpecs.statusEquals(OrderStatus.COMPLETED))
                     .and(OrderItemSpecs.priceBetween(
                             new BigDecimal("100"), new BigDecimal("500")))
                     .and(ItemTagSpecs.tagCategoryEquals("PROMO"))
                     .and(TagAttributeSpecs.attributeNameEquals("COLOR"));

5Ô∏è‚É£ Optional: Dynamic ‚Äúsearch by everything‚Äù builder

This avoids manual .and() chaining.

public class OrderSearchCriteria {
    String customer;
    OrderStatus status;
    LocalDate fromDate;
    LocalDate toDate;
    String product;
    BigDecimal minPrice;
    BigDecimal maxPrice;
    String tagName;
    String tagCategory;
    String attributeName;
    String attributeValue;
}

public class OrderSpecificationBuilder {

    public static Specification<Order> build(OrderSearchCriteria c) {
        return Specification.where(BaseSpecifications.withJoinContext())
                .and(OrderSpecs.customerEquals(c.customer))
                .and(OrderSpecs.statusEquals(c.status))
                .and(OrderSpecs.orderDateBetween(c.fromDate, c.toDate))
                .and(OrderItemSpecs.productEquals(c.product))
                .and(OrderItemSpecs.priceBetween(c.minPrice, c.maxPrice))
                .and(ItemTagSpecs.tagNameEquals(c.tagName))
                .and(ItemTagSpecs.tagCategoryEquals(c.tagCategory))
                .and(TagAttributeSpecs.attributeNameEquals(c.attributeName))
                .and(TagAttributeSpecs.attributeValueEquals(c.attributeValue));
    }
}

6Ô∏è‚É£ Why this does NOT compromise composability
Concern	Result
Single responsibility	‚úî One spec = one attribute
Reusability	‚úî Any combination
Join duplication	‚úî JoinContext
Optional filters	‚úî cb.conjunction()
Scalability	‚úî Add attribute ‚Üí add spec
Readability	‚úî Explicit intent
7Ô∏è‚É£ Golden rule (memorize this)

You compose behavior, not queries.

You never ask:

‚ÄúWhich query do I need?‚Äù

You ask:

‚ÄúWhich predicates apply?‚Äù

Final takeaway

This pattern gives you:

‚úî Unlimited attributes
‚úî Dynamic AND / OR composition
‚úî Deep joins
‚úî Zero duplicate joins
‚úî Clean, testable code

If you want next, I can:

Add OR groups

Show multi-value filters (IN)

Add case-insensitive / LIKE searching

Convert this to QueryDSL-style DSL

Just tell me.

Can i group predicates under methods like searchfull() adds all predicates searchhalf() adds half of predicates only and use this methods to generate Specifications for search

Yes ‚Äî you absolutely can, and if you do it the right way, it does NOT compromise composability.

The key is what you group.

‚úÖ You may group compositions of specs
‚ùå You should NOT group logic inside specs

Below is the correct, scalable pattern.

Core rule (very important)

Specifications stay atomic.
Grouping methods only compose them.

Think in layers:

[ Attribute Specs ]  ‚Üí  [ Grouped Specs ]  ‚Üí  [ Search Builders ]

1Ô∏è‚É£ Attribute specs remain unchanged

Example (already correct):

OrderSpecs.customerEquals(...)
OrderItemSpecs.productEquals(...)
ItemTagSpecs.tagCategoryEquals(...)
TagAttributeSpecs.attributeNameEquals(...)


These are never aware of grouping.

2Ô∏è‚É£ Grouped specifications (your searchFull, searchHalf)

These are just compositions.

public final class OrderSearchGroups {

    private OrderSearchGroups() {}

    public static Specification<Order> searchFull(OrderSearchCriteria c) {
        return Specification
                .where(OrderSpecs.customerEquals(c.customer))
                .and(OrderSpecs.statusEquals(c.status))
                .and(OrderSpecs.orderDateBetween(c.fromDate, c.toDate))
                .and(OrderItemSpecs.productEquals(c.product))
                .and(OrderItemSpecs.priceBetween(c.minPrice, c.maxPrice))
                .and(ItemTagSpecs.tagNameEquals(c.tagName))
                .and(ItemTagSpecs.tagCategoryEquals(c.tagCategory))
                .and(TagAttributeSpecs.attributeNameEquals(c.attributeName))
                .and(TagAttributeSpecs.attributeValueEquals(c.attributeValue));
    }

    public static Specification<Order> searchHalf(OrderSearchCriteria c) {
        return Specification
                .where(OrderSpecs.customerEquals(c.customer))
                .and(OrderItemSpecs.productEquals(c.product))
                .and(ItemTagSpecs.tagCategoryEquals(c.tagCategory))
                .and(TagAttributeSpecs.attributeNameEquals(c.attributeName));
    }
}


‚úî No joins
‚úî No predicates
‚úî No JPA logic

Just composition.

3Ô∏è‚É£ Always wrap with base spec
Specification<Order> spec =
        Specification.where(BaseSpecifications.withJoinContext())
                     .and(OrderSearchGroups.searchFull(criteria));


Or:

Specification<Order> spec =
        BaseSpecifications.withJoinContext()
                .and(OrderSearchGroups.searchHalf(criteria));

4Ô∏è‚É£ Why this works perfectly
Risk	Why it‚Äôs safe
Hard-coded queries	‚ùå avoided
Duplicate joins	‚ùå JoinContext
Spec explosion	‚ùå grouping reduces noise
Loss of flexibility	‚ùå still composable
Testing difficulty	‚ùå groups testable
5Ô∏è‚É£ Advanced: conditional grouping

You can make groups data-driven.

public static Specification<Order> searchMinimal(OrderSearchCriteria c) {
    Specification<Order> spec = Specification.where(null);

    if (c.customer != null) {
        spec = spec.and(OrderSpecs.customerEquals(c.customer));
    }
    if (c.product != null) {
        spec = spec.and(OrderItemSpecs.productEquals(c.product));
    }
    if (c.tagCategory != null) {
        spec = spec.and(ItemTagSpecs.tagCategoryEquals(c.tagCategory));
    }
    return spec;
}


This is useful for role-based searching or API versions.

6Ô∏è‚É£ Even better: enum-based grouping (clean API)
public enum SearchMode {
    FULL,
    HALF,
    MINIMAL
}

public static Specification<Order> byMode(
        SearchMode mode, OrderSearchCriteria c) {

    return switch (mode) {
        case FULL -> searchFull(c);
        case HALF -> searchHalf(c);
        case MINIMAL -> searchMinimal(c);
    };
}

7Ô∏è‚É£ What NOT to do (anti-pattern üö´)
// ‚ùå BAD
public static Specification<Order> searchFull(...) {
    return (root, query, cb) -> {
        // joins
        // predicates
        // conditions
    };
}


Why bad?

Not composable

Not reusable

Hard to test

Breaks JoinContext pattern

8Ô∏è‚É£ Mental model (remember this)

Specifications describe ‚Äúwhat‚Äù
Groups describe ‚Äúwhen together‚Äù

Final answer

‚úî Yes, group predicates via grouping methods
‚úî Keep attribute specs atomic
‚úî Group only by composing specs
‚úî Wrap everything with your base JoinContext spec

This gives you:

Clean API

Maximum flexibility

Zero duplication

Long-term maintainability

If you want next, I can show:

OR-grouped searches ((A AND B) OR (C AND D))

Role-based predicate groups

Pagination + sorting with grouped specs

Just say it.

Pagination + sorting with grouped specs

Great question ‚Äî pagination + sorting is exactly where grouped specs shine, and Spring Data already gives you most of what you need.
The trick is to keep pagination & sorting outside the specs, while still supporting deep-join sorting.

Below is a clean, production-grade setup that works with:

‚úî grouped specifications (searchFull, searchHalf)
‚úî deep joins (items ‚Üí tags ‚Üí attributes)
‚úî pagination
‚úî sorting (root + nested fields)
‚úî zero duplicate joins

1Ô∏è‚É£ Repository setup
public interface OrderRepository
        extends JpaRepository<Order, Long>,
                JpaSpecificationExecutor<Order> {
}


This is required.

2Ô∏è‚É£ Rule: specs never know about paging

Specifications filter.
Pageable paginates.
Sort orders.

This separation keeps everything composable.

3Ô∏è‚É£ Simple pagination + sorting (root fields)
Pageable pageable =
        PageRequest.of(
                0,                      // page
                20,                     // size
                Sort.by(
                        Sort.Order.desc("orderDate"),
                        Sort.Order.asc("customer")
                )
        );

Specification<Order> spec =
        BaseSpecifications.withJoinContext()
                .and(OrderSearchGroups.searchFull(criteria));

Page<Order> page = orderRepository.findAll(spec, pageable);


‚úî Works out of the box
‚úî Uses grouped specs
‚úî No extra code

4Ô∏è‚É£ Sorting by nested attributes (the tricky part)

Spring cannot automatically sort across joins in Specification.
You must apply ordering inside the spec using the same JoinContext.

5Ô∏è‚É£ SortSpec (composable ordering)
Sort request model
public record OrderSort(
        String property,
        Sort.Direction direction
) {}


Examples:

"customer"

"items.product"

"items.tags.name"

"items.tags.attributes.value"

Sort specification
public final class OrderSortSpecification {

    private OrderSortSpecification() {}

    public static Specification<Order> applySort(List<OrderSort> sorts) {
        return (root, query, cb) -> {
            if (sorts == null || sorts.isEmpty()) {
                return cb.conjunction();
            }

            JoinContext ctx = JoinContextHolder.get(query);
            List<Order> orders = new ArrayList<>();

            for (OrderSort sort : sorts) {
                Path<?> path = resolvePath(root, ctx, sort.property());
                orders.add(
                        sort.direction() == Sort.Direction.ASC
                                ? cb.asc(path)
                                : cb.desc(path)
                );
            }

            query.orderBy(orders);
            return cb.conjunction();
        };
    }

    private static Path<?> resolvePath(
            Root<Order> root,
            JoinContext ctx,
            String propertyPath
    ) {
        String[] parts = propertyPath.split("\\.");
        From<?, ?> from = root;

        for (int i = 0; i < parts.length - 1; i++) {
            from = ctx.getOrCreate(from, parts[i], JoinType.LEFT);
        }
        return from.get(parts[parts.length - 1]);
    }
}


‚úî Reuses joins
‚úî Unlimited depth
‚úî Works with grouped specs

6Ô∏è‚É£ Pagination + deep sorting together
Specification<Order> spec =
        BaseSpecifications.withJoinContext()
                .and(OrderSearchGroups.searchHalf(criteria))
                .and(OrderSortSpecification.applySort(
                        List.of(
                                new OrderSort("orderDate", Sort.Direction.DESC),
                                new OrderSort("items.product", Sort.Direction.ASC),
                                new OrderSort("items.tags.name", Sort.Direction.ASC)
                        )
                ));

Pageable pageable = PageRequest.of(0, 20);

Page<Order> page = orderRepository.findAll(spec, pageable);


üìå Note:

When ordering is applied inside the spec, do NOT pass Sort to Pageable

Pageable still controls limit / offset

7Ô∏è‚É£ Mixed mode (root sort via Pageable, deep sort via spec)

Allowed ‚Äî but be explicit.

Pageable pageable =
        PageRequest.of(
                0,
                20,
                Sort.by("customer") // root field only
        );

Specification<Order> spec =
        BaseSpecifications.withJoinContext()
                .and(OrderSearchGroups.searchFull(criteria))
                .and(OrderSortSpecification.applySort(
                        List.of(
                                new OrderSort("items.price", Sort.Direction.DESC)
                        )
                ));

8Ô∏è‚É£ Avoid common pitfalls üö®
1. Missing distinct(true)

Always ensure:

query.distinct(true);


Handled already in BaseSpecifications.withJoinContext().

2. Sorting on collections

Sorting by collection attributes:

Can duplicate rows internally

Works correctly only with distinct

3. Pageable sort + spec sort conflict

If both are provided:

JPA provider may ignore one

Prefer spec-based ordering for nested paths

9Ô∏è‚É£ Controller example (clean API)
@GetMapping("/orders")
public Page<Order> search(
        OrderSearchCriteria criteria,
        @RequestParam SearchMode mode,
        @RequestParam int page,
        @RequestParam int size,
        @RequestParam List<String> sort
) {
    List<OrderSort> sorts = sort.stream()
            .map(s -> {
                String[] p = s.split(",");
                return new OrderSort(p[0], Sort.Direction.fromString(p[1]));
            })
            .toList();

    Specification<Order> spec =
            BaseSpecifications.withJoinContext()
                    .and(OrderSearchGroups.byMode(mode, criteria))
                    .and(OrderSortSpecification.applySort(sorts));

    return orderRepository.findAll(
            spec,
            PageRequest.of(page, size)
    );
}


Example request:

/orders?mode=FULL&page=0&size=20
&sort=orderDate,DESC
&sort=items.tags.name,ASC

üîë Mental model (remember this)
Specifications  ‚Üí filtering + ordering
Pageable        ‚Üí paging only
Grouping        ‚Üí reuse
JoinContext     ‚Üí safety

Final takeaway

‚úî Grouped specs work perfectly with pagination
‚úî Deep sorting is solved via a dedicated SortSpec
‚úî Paging remains clean & independent
‚úî No loss of composability

If you want next, I can show:

Multi-column OR sorting

NULLS FIRST / LAST

Case-insensitive sorting

Cursor-based pagination with specs

Just tell me.

With this code does not hibernate throws HHH000104: firstResult/maxResults specified with collection fetch; applying in memory

Short answer: yes, with the code as shown you can trigger

HHH000104: firstResult/maxResults specified with collection fetch; applying in memory


but only under specific conditions ‚Äî and it‚Äôs fixable without giving up grouped specs or deep sorting.

Let‚Äôs break it down precisely and then fix it properly.

Why this warning happens (exact reason)

Hibernate throws HHH000104 when ALL of the following are true:

Pagination is applied (setFirstResult / setMaxResults)

A collection is fetched (join fetch or implicit fetch join)

The collection is to-many (@OneToMany, @ManyToMany)

Hibernate cannot paginate SQL rows correctly when a collection fetch join multiplies rows, so it:

Fetches everything

Applies pagination in memory

Emits the warning

Important clarification (your current code)
‚úÖ Your specs use join(), NOT fetch()
ctx.getOrCreate(root, "items", JoinType.LEFT);


This is a normal join, not a fetch join.

‚û° Normal joins do NOT trigger HHH000104

So by default, the setup I gave you does NOT cause the warning.

When you WILL see HHH000104

You will get the warning if anywhere in the query you do this:

root.fetch("items", JoinType.LEFT);


or

items.fetch("tags", JoinType.LEFT);


or Hibernate decides to fetch because of:

@EntityGraph with collections

FetchType.EAGER on collections

Custom repository method with JOIN FETCH

Typical mistake that causes it üö®

People often ‚Äúoptimize‚Äù like this:

Join<Order, OrderItem> items =
        (Join<Order, OrderItem>) root.fetch("items", JoinType.LEFT);


‚ùå This immediately breaks pagination.

The golden rule (memorize this)

Never use FETCH JOIN on collections in paginated queries

Correct architecture (production-grade)
Step 1: Page IDs only (no fetch joins)

Your current specification setup is already correct for this.

Page<Order> page = orderRepository.findAll(spec, pageable);


This query:

Filters

Sorts

Paginates

Uses joins, not fetch joins

‚úÖ No HHH000104

Step 2: Fetch associations in a SECOND query

After pagination, fetch the graph by IDs.

Option A: @EntityGraph (recommended)
@EntityGraph(attributePaths = {
        "items",
        "items.tags",
        "items.tags.attributes"
})
List<Order> findByIdIn(Collection<Long> ids);


Usage:

Page<Order> page = orderRepository.findAll(spec, pageable);

List<Order> content =
        orderRepository.findByIdIn(
                page.getContent()
                    .stream()
                    .map(Order::getId)
                    .toList()
        );


‚úî Pagination safe
‚úî No warning
‚úî One extra query
‚úî Correct object graph

Option B: Batch fetching (simpler)
@OneToMany(mappedBy = "order")
@BatchSize(size = 50)
private Set<OrderItem> items;


Hibernate will fetch collections in batches without fetch joins.

‚úî No warning
‚úî Less SQL
‚úî Works well for read-heavy systems

What about sorting by collection attributes?

Sorting does NOT require fetch joins.

This is safe:

LEFT JOIN items
ORDER BY items.product


Hibernate only fetches root entities.

Checklist: how to guarantee NO HHH000104
‚úÖ Do this

Use join() only

Keep distinct(true)

Paginate only root entity

Fetch collections separately

‚ùå Never do this

fetch() on @OneToMany with pagination

@EntityGraph on paged query

FetchType.EAGER on collections

Sanity check for your current design
Feature	Safe
Grouped specs	‚úÖ
JoinContext	‚úÖ
Deep filtering	‚úÖ
Deep sorting	‚úÖ
Pagination	‚úÖ
Fetch joins	‚ùå (don‚Äôt use)
Final verdict

üëâ Your composable specification + pagination + sorting design is correct and safe

You only get HHH000104 if you:

add fetch joins

or use entity graphs on paged queries

If you want, I can:

Refactor your repo to a 2-phase fetch pattern

Show a DTO projection approach

Explain why Hibernate can‚Äôt fix this internally

Just tell me which one you want.

Refactor my repo to a 2-phase fetch pattern transparently

Great, this is the right fix üëç
Below is a clean, transparent 2-phase fetch refactor that:

‚úî avoids HHH000104
‚úî keeps your existing Specification API unchanged
‚úî supports grouped specs, deep joins, sorting, pagination
‚úî is transparent to callers (service calls one method)

Goal

You want callers to do this:

Page<Order> page = orderRepository.search(spec, pageable);


‚Ä¶and never think about:

pagination limitations

fetch joins

entity graphs

Hibernate warnings

1Ô∏è‚É£ Split repository responsibilities
1.1 Base repository (unchanged)
public interface OrderRepository
        extends JpaRepository<Order, Long>,
                JpaSpecificationExecutor<Order> {
}

1.2 Custom repository API (transparent search)
public interface OrderSearchRepository {
    Page<Order> search(Specification<Order> spec, Pageable pageable);
}

2Ô∏è‚É£ Custom repository implementation

Spring Data naming rule is critical:

<OrderRepository>Impl

OrderRepositoryImpl
@Repository
@RequiredArgsConstructor
public class OrderRepositoryImpl implements OrderSearchRepository {

    private final EntityManager em;
    private final OrderRepository orderRepository;

    @Override
    public Page<Order> search(
            Specification<Order> spec,
            Pageable pageable
    ) {

        // ---------- Phase 1: page ONLY root entities ----------
        Page<Order> page = orderRepository.findAll(spec, pageable);

        if (page.isEmpty()) {
            return page;
        }

        // ---------- Phase 2: fetch associations by IDs ----------
        List<Long> ids = page.getContent()
                .stream()
                .map(Order::getId)
                .toList();

        List<Order> fetched =
                em.createQuery("""
                    select distinct o
                    from Order o
                    left join fetch o.items i
                    left join fetch i.tags t
                    left join fetch t.attributes
                    where o.id in :ids
                    """, Order.class)
                  .setParameter("ids", ids)
                  .getResultList();

        // ---------- Preserve pagination order ----------
        Map<Long, Order> byId = fetched.stream()
                .collect(Collectors.toMap(Order::getId, Function.identity()));

        List<Order> ordered = page.getContent()
                .stream()
                .map(o -> byId.get(o.getId()))
                .toList();

        return new PageImpl<>(ordered, pageable, page.getTotalElements());
    }
}

3Ô∏è‚É£ Wire it transparently

Update your main repository to extend both interfaces:

public interface OrderRepository
        extends JpaRepository<Order, Long>,
                JpaSpecificationExecutor<Order>,
                OrderSearchRepository {
}


Now Spring will:

Use OrderRepositoryImpl automatically

Expose search() on OrderRepository

4Ô∏è‚É£ Service layer (zero changes for callers)
@Service
@RequiredArgsConstructor
public class OrderService {

    private final OrderRepository orderRepository;

    public Page<Order> searchOrders(
            OrderSearchCriteria criteria,
            SearchMode mode,
            Pageable pageable
    ) {
        Specification<Order> spec =
                BaseSpecifications.withJoinContext()
                        .and(OrderSearchGroups.byMode(mode, criteria));

        return orderRepository.search(spec, pageable);
    }
}


‚úî No warnings
‚úî Fully initialized graph
‚úî Pagination correct
‚úî Sorting preserved

5Ô∏è‚É£ Why this works (important)
Phase	Purpose
Phase 1	DB-level pagination
Phase 2	Graph fetching
No fetch join in phase 1	Avoids HHH000104
ID-based fetch	Stable + efficient
Reordering	Pagination correctness
6Ô∏è‚É£ Performance notes (real-world)
‚úî SQL count

2 queries total

Predictable

Cache-friendly

‚úî Large pages

Works well even with size=100

‚úî Index usage

Phase 1 uses indexes for filters + sort

7Ô∏è‚É£ Optional improvements
7.1 EntityGraph variant (cleaner JPQL)
@EntityGraph(attributePaths = {
        "items",
        "items.tags",
        "items.tags.attributes"
})
@Query("select o from Order o where o.id in :ids")
List<Order> fetchGraph(@Param("ids") List<Long> ids);


Replace Phase 2 with:

List<Order> fetched = orderRepository.fetchGraph(ids);

7.2 Batch fetching (if graph is huge)
@BatchSize(size = 50)
@OneToMany(mappedBy = "order")
private Set<OrderItem> items;


Use when collections are optional.

8Ô∏è‚É£ What NOT to do üö´
@EntityGraph(...) // ‚ùå on paged query
Page<Order> findAll(Specification spec, Pageable pageable);


or

root.fetch("items") // ‚ùå in specs

9Ô∏è‚É£ Final mental model
SEARCH = filter + sort + page
FETCH  = separate concern


You solved this the correct way.

Final result

‚úî Transparent API
‚úî No Hibernate warnings
‚úî Clean architecture
‚úî Future-proof

If you want next, I can:

Generalize this pattern for any aggregate

Convert it into a base repository

Show a DTO + projection version

Just say which one.

Don't use jql or sql. Refactor second fetch to use repository capabilities

Perfect constraint üëç
We‚Äôll keep everything inside Spring Data repository capabilities, no JPQL / no SQL, and still keep the 2-phase fetch transparent.

The clean solution here is EntityGraph + findAllById (or a derived query) in phase 2.

Target API (unchanged for callers)
Page<Order> page = orderRepository.search(spec, pageable);

1Ô∏è‚É£ Repository refactor (no JPQL, no SQL)
1.1 Main repository
public interface OrderRepository
        extends JpaRepository<Order, Long>,
                JpaSpecificationExecutor<Order>,
                OrderSearchRepository {
}

1.2 EntityGraph-enabled fetch (Spring Data only)
public interface OrderGraphRepository {

    @EntityGraph(attributePaths = {
            "items",
            "items.tags",
            "items.tags.attributes"
    })
    List<Order> findAllById(Iterable<Long> ids);
}


‚ö†Ô∏è Important
This is NOT used with pagination ‚Äî only for phase 2.

1.3 Compose repositories (Spring magic)

Spring allows repository interface composition.

public interface OrderRepository
        extends JpaRepository<Order, Long>,
                JpaSpecificationExecutor<Order>,
                OrderSearchRepository,
                OrderGraphRepository {
}

2Ô∏è‚É£ Custom repository implementation (transparent 2-phase fetch)
OrderRepositoryImpl
@Repository
@RequiredArgsConstructor
public class OrderRepositoryImpl implements OrderSearchRepository {

    private final OrderRepository delegate;

    @Override
    public Page<Order> search(
            Specification<Order> spec,
            Pageable pageable
    ) {
        // ---------- Phase 1: paged root query ----------
        Page<Order> page = delegate.findAll(spec, pageable);

        if (page.isEmpty()) {
            return page;
        }

        // ---------- Phase 2: fetch graph by IDs ----------
        List<Long> ids = page.getContent()
                .stream()
                .map(Order::getId)
                .toList();

        List<Order> fetched = delegate.findAllById(ids);

        // ---------- Preserve pagination order ----------
        Map<Long, Order> byId = fetched.stream()
                .collect(Collectors.toMap(Order::getId, Function.identity()));

        List<Order> ordered = page.getContent()
                .stream()
                .map(o -> byId.get(o.getId()))
                .toList();

        return new PageImpl<>(ordered, pageable, page.getTotalElements());
    }
}


‚úî No JPQL
‚úî No SQL
‚úî No Hibernate warning
‚úî Fully initialized graph

3Ô∏è‚É£ Why this is safe
Aspect	Why
Pagination	Only in phase 1
EntityGraph	Only in phase 2
Collection fetch	Not paged
Spring Data only	‚úî
Composable specs	‚úî
4Ô∏è‚É£ Important EntityGraph rules
‚úÖ Allowed
@EntityGraph
List<Order> findAllById(Iterable<Long> ids);

‚ùå Forbidden
@EntityGraph
Page<Order> findAll(Specification spec, Pageable pageable);


This would reintroduce HHH000104.

5Ô∏è‚É£ Optional: dynamic graph selection

If you want different graphs per use case:

@NamedEntityGraph(
        name = "order.full",
        attributeNodes = @NamedAttributeNode(value = "items", subgraph = "items"),
        subgraphs = {
                @NamedSubgraph(
                        name = "items",
                        attributeNodes = @NamedAttributeNode(value = "tags", subgraph = "tags")
                ),
                @NamedSubgraph(
                        name = "tags",
                        attributeNodes = @NamedAttributeNode("attributes")
                )
        }
)
@Entity
public class Order { ... }

@EntityGraph("order.full")
List<Order> findAllById(Iterable<Long> ids);

6Ô∏è‚É£ Zero changes to specs / grouping / sorting

Your existing:

JoinContext

Grouped specs

Sorting spec

Pagination

remain unchanged.

7Ô∏è‚É£ Final mental model
Spec + Pageable  ‚Üí IDs
EntityGraph      ‚Üí Object graph
Reorder          ‚Üí Correct page

Final takeaway

You now have a fully transparent, Spring-only, warning-free, scalable 2-phase fetch that:

‚úî respects Hibernate limits
‚úî keeps composability
‚úî avoids JPQL/SQL entirely

If you want next, I can:

Generalize this into a BaseSearchRepository

Add conditional graphs

Show a DTO-based alternative

Just say the word.

Generalize this into a BaseSearchRepository and add conditional graphs

Excellent ‚Äî this is the final form of the pattern.
We‚Äôll build a generic, reusable BaseSearchRepository with conditional EntityGraphs, while keeping:

‚úî Spring Data only (no JPQL / SQL)
‚úî Specifications untouched
‚úî Pagination safe
‚úî Fetch strategy configurable per use case
‚úî Transparent to callers

1Ô∏è‚É£ Design goals (so the solution makes sense)

We want:

Page<Order> page =
    orderRepository.search(spec, pageable, FetchProfile.FULL);


And we want the same base infrastructure to work for:

Order

any other aggregate root

different fetch depths (LIGHT, FULL, etc.)

2Ô∏è‚É£ Fetch profile abstraction (conditional graphs)
2.1 FetchProfile enum
public enum FetchProfile {
    NONE,       // no second fetch
    LIGHT,      // shallow graph
    FULL        // deep graph
}

2.2 Graph selector interface (entity-specific)

Each aggregate decides which graph to use.

public interface GraphSelector<T, ID> {

    FetchProfile defaultProfile();

    List<T> fetch(
            FetchProfile profile,
            Iterable<ID> ids
    );
}


This keeps the base repository generic.

3Ô∏è‚É£ BaseSearchRepository (generic contract)
public interface BaseSearchRepository<T, ID> {

    Page<T> search(
            Specification<T> spec,
            Pageable pageable,
            FetchProfile profile
    );
}

4Ô∏è‚É£ BaseSearchRepositoryImpl (generic implementation)

This is the core reusable engine.

@RequiredArgsConstructor
public abstract class BaseSearchRepositoryImpl<T, ID>
        implements BaseSearchRepository<T, ID> {

    private final JpaSpecificationExecutor<T> specRepo;
    private final GraphSelector<T, ID> graphSelector;

    @Override
    public Page<T> search(
            Specification<T> spec,
            Pageable pageable,
            FetchProfile profile
    ) {
        // ---------- Phase 1: paged root query ----------
        Page<T> page = specRepo.findAll(spec, pageable);

        if (page.isEmpty() || profile == FetchProfile.NONE) {
            return page;
        }

        // ---------- Phase 2: fetch graph ----------
        List<ID> ids = page.getContent()
                .stream()
                .map(this::getId)
                .toList();

        FetchProfile effectiveProfile =
                profile != null
                        ? profile
                        : graphSelector.defaultProfile();

        List<T> fetched =
                graphSelector.fetch(effectiveProfile, ids);

        // ---------- Preserve pagination order ----------
        Map<ID, T> byId = fetched.stream()
                .collect(Collectors.toMap(this::getId, Function.identity()));

        List<T> ordered = page.getContent()
                .stream()
                .map(e -> byId.get(this.getId(e)))
                .toList();

        return new PageImpl<>(ordered, pageable, page.getTotalElements());
    }

    /**
     * Each entity defines how to extract its ID
     */
    protected abstract ID getId(T entity);
}


‚úî No entity knowledge
‚úî No JPQL
‚úî No SQL
‚úî Fully reusable

5Ô∏è‚É£ Order-specific graph configuration
5.1 Named EntityGraphs on entity
@NamedEntityGraph(
        name = "order.light",
        attributeNodes = @NamedAttributeNode("items")
)
@NamedEntityGraph(
        name = "order.full",
        attributeNodes = @NamedAttributeNode(
                value = "items",
                subgraph = "items"
        ),
        subgraphs = {
                @NamedSubgraph(
                        name = "items",
                        attributeNodes = @NamedAttributeNode(
                                value = "tags",
                                subgraph = "tags"
                        )
                ),
                @NamedSubgraph(
                        name = "tags",
                        attributeNodes = @NamedAttributeNode("attributes")
                )
        }
)
@Entity
public class Order {
    ...
}

5.2 OrderGraphSelector (entity-specific)
@Component
@RequiredArgsConstructor
public class OrderGraphSelector
        implements GraphSelector<Order, Long> {

    private final OrderRepository repo;

    @Override
    public FetchProfile defaultProfile() {
        return FetchProfile.LIGHT;
    }

    @Override
    public List<Order> fetch(
            FetchProfile profile,
            Iterable<Long> ids
    ) {
        return switch (profile) {
            case LIGHT -> repo.findAllById(ids); // default graph
            case FULL -> repo.findAllWithFullGraph(ids);
            default -> repo.findAllById(ids);
        };
    }
}

5.3 Repository methods (Spring Data only)
public interface OrderRepository
        extends JpaRepository<Order, Long>,
                JpaSpecificationExecutor<Order>,
                BaseSearchRepository<Order, Long> {

    @EntityGraph("order.full")
    List<Order> findAllWithFullGraph(Iterable<Long> ids);
}


‚ö†Ô∏è No pagination here ‚Äî safe.

6Ô∏è‚É£ OrderSearchRepositoryImpl (glue code)
@Repository
public class OrderSearchRepositoryImpl
        extends BaseSearchRepositoryImpl<Order, Long> {

    public OrderSearchRepositoryImpl(
            OrderRepository repo,
            OrderGraphSelector selector
    ) {
        super(repo, selector);
    }

    @Override
    protected Long getId(Order entity) {
        return entity.getId();
    }
}

7Ô∏è‚É£ Service usage (clean & explicit)
Specification<Order> spec =
        BaseSpecifications.withJoinContext()
                .and(OrderSearchGroups.byMode(mode, criteria));

Page<Order> page =
        orderRepository.search(
                spec,
                pageable,
                FetchProfile.FULL
        );


Or lightweight:

orderRepository.search(spec, pageable, FetchProfile.NONE);

8Ô∏è‚É£ Why this architecture scales
Concern	Solved
Pagination safety	‚úî
Conditional fetching	‚úî
Composable specs	‚úî
No Hibernate warnings	‚úî
Entity-specific graphs	‚úî
Reusable core	‚úî
9Ô∏è‚É£ How to add another entity

For Customer, you only add:

@NamedEntityGraphs

CustomerGraphSelector

CustomerSearchRepositoryImpl

Zero changes to base logic.

üîë Final mental model
BaseSearchRepository ‚Üí infrastructure
GraphSelector        ‚Üí entity-specific fetch
Specification        ‚Üí filtering
Pageable             ‚Üí paging

Final takeaway

You now have:

‚úî A generic, reusable, production-grade search engine
‚úî Safe pagination
‚úî Conditional deep fetch
‚úî Clean separation of concerns
‚úî Spring Data only

If you want next, I can:

Add multi-aggregate search

Show DTO projections with the same base

Add role-based graph selection

Just say the word.