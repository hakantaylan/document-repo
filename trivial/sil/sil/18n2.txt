I have a group of microservices and a common library which contains enums for all  lookup data of all microservice's. Can i keep bundle files regarding this enums (acts as codes) in this common library and use it for i18n purposes

Short answer: yes, you can â€” but there are some important architectural trade-offs. In most microservice systems, itâ€™s usually not the best long-term approach.

Letâ€™s break it down clearly and pragmatically.

What youâ€™re proposing

A common library shared by multiple microservices

This library contains:

Enums representing lookup / code values

i18n bundle files (e.g., messages_en.properties, JSON, etc.) mapping enum values â†’ localized strings

Each microservice uses those bundles to display localized text

This is a centralized code + translation model.

When this can work well âœ…

This approach is reasonable if most of the following are true:

The enums are truly global

Stable concepts like:

OrderStatus

CountryCode

Currency

Yes/No

Not business-logic-specific states

Low change frequency

Enums and translations donâ€™t change often

Adding a new value requires coordinated releases anyway

Synchronous release model

Services are already released together

Youâ€™re okay redeploying services when the common lib changes

Backend-driven localization

Backend returns localized labels (not just codes)

UI is thin or shared

In this case, bundling enums + i18n files in a common library is simple and pragmatic.

Why this is risky in microservices âŒ

In many microservice architectures, this causes tight coupling.

1. Version coupling

If you:

Add an enum value

Fix a translation

Add a new language

â¡ Every service must upgrade the common library

This breaks independent deployability â€” one of the main benefits of microservices.

2. Domain leakage

Not all services:

Need the same enums

Interpret them the same way

Want the same wording

Example:

OrderStatus.CANCELLED


Billing service: â€œCancelledâ€

Customer service: â€œCancelled by customerâ€

Ops service: â€œOrder voidedâ€

A shared i18n bundle forces one meaning everywhere.

3. Backend localization doesnâ€™t scale well

If localization is in the backend:

Every request must know locale

Caching is harder

UI flexibility is reduced

Modern systems often prefer:

Backend â†’ codes

Frontend â†’ localization

Recommended patterns (better long-term options)
âœ… Best practice for microservices

Backend returns codes, frontend localizes

{
  "status": "ORDER_CANCELLED"
}


Frontend:

{
  "ORDER_CANCELLED": "Order cancelled"
}


Pros

Services stay decoupled

UI teams control wording

Translations can change without backend redeploys

âœ… Shared enums, but NOT translations

If you want some sharing:

Common library:

Enums / constants only

Each service or UI:

Own i18n bundles

This keeps:

Compile-time safety for codes

Runtime flexibility for translations

âœ… Dedicated â€œreference dataâ€ / localization service

For large systems:

Central service:

Lookup codes

Localized labels

Services call it when needed (or cache results)

Useful if:

Many consumers (UI, batch jobs, APIs)

Frequent translation updates

If you do keep i18n bundles in the common library

Follow these rules to reduce pain:

Only for truly global concepts

Never include service-specific enums

Version aggressively

Do not localize user-facing sentences

Only short labels, not messages

Treat translations as data, not logic

Summary
Approach	Recommendation
Common lib + enums + i18n	âš ï¸ Acceptable for small / tightly coupled systems
Common lib + enums only	âœ… Good balance
Backend returns codes, UI localizes	â­ Best practice
Central localization service	â­ For large systems

If you want, tell me:

Backend-only or UI involved?

How many services?

How often enums/translations change?

I can suggest a concrete structure (Maven/Gradle, Spring, Node, etc.) tailored to your stack.

All lookups areglobal. No need for interpreting same enum for different microservices/domains. It is global

Got it â€” that clarification matters ğŸ‘
If all lookups are truly global, semantically identical everywhere, and intended to be interpreted the same way across all microservices, then yes, keeping the enum codes and their i18n bundles in a common library is a valid and defensible design.

That said, there are still a few important design rules you should follow to avoid future pain.

When your approach is architecturally sound

Your scenario fits these conditions:

Lookup values are canonical, not domain-specific
(e.g., Country, Currency, Gender, Yes/No, Status codes with universal meaning)

Text is descriptive labels, not business messages

Backend services are authoritative for lookup data

You want consistency across all services and consumers

Release cadence is acceptable if lookups change

In this case, the common library acts as a reference data module, not just a shared utility.

Recommended structure for the common library
1. Separate codes from labels

Even if they live in the same library, keep them conceptually distinct.

common-lookups/
â”œâ”€â”€ src/main/java
â”‚   â””â”€â”€ com.example.lookups
â”‚       â”œâ”€â”€ CountryCode.java
â”‚       â”œâ”€â”€ CurrencyCode.java
â”‚       â”œâ”€â”€ OrderStatusCode.java
â”‚
â”œâ”€â”€ src/main/resources
â”‚   â””â”€â”€ i18n
â”‚       â”œâ”€â”€ lookups_en.properties
â”‚       â”œâ”€â”€ lookups_fr.properties
â”‚       â””â”€â”€ lookups_de.properties


Enum example:

public enum OrderStatusCode {
    CREATED,
    APPROVED,
    CANCELLED
}


Properties:

OrderStatusCode.CREATED=Created
OrderStatusCode.APPROVED=Approved
OrderStatusCode.CANCELLED=Cancelled


â¡ This keeps the enum value stable and the label changeable.

2. Enums must be append-only

Once published:

âŒ Never rename enum values

âŒ Never change meaning

âœ… Only add new ones

This is critical when enums are used across services and persisted.

3. Treat the library as versioned reference data

Your common library is effectively a shared contract.

Use semantic versioning

Bump minor for new values

Bump major if anything breaking changes (ideally never)

4. Donâ€™t over-localize

Keep i18n content limited to:

âœ… Short labels
âŒ Sentences
âŒ User-specific messaging
âŒ Error messages

Example of good:

CountryCode.DE=Germany


Example of bad:

OrderStatus.CANCELLED=The order has been cancelled successfully

5. Expose codes in APIs, not labels (recommended)

Even if services can localize:

{
  "status": "CANCELLED"
}


Optional (if needed):

{
  "status": "CANCELLED",
  "statusLabel": "Cancelled"
}


This preserves:

API stability

Future UI flexibility

Risks to watch (even in your case)

Even with â€œglobalâ€ lookups, problems arise if:

Translation updates are frequent

Non-Java consumers need access (mobile apps, JS, external APIs)

You later add tenant-specific or customizable labels

If any of those become likely, you may want:

A lookup service

Or exporting bundles as data artifacts (JSON/YAML) instead of code

Verdict

Your approach is valid and clean given your constraints.
It is effectively a centralized reference data + localization module, which is acceptable when:

Meanings are universal

Change rate is low

Teams accept coordinated upgrades

If you want, I can:

Review your enum naming conventions

Suggest a fallback strategy if localization fails

Help design a migration path if this ever outgrows a common library

Just tell me your stack (Java/Spring? Node? .NET?).

how exporting bundles as data artifacts (JSON/YAML) instead of code can be done

Great question. Exporting i18n bundles as data artifacts (JSON/YAML) instead of embedding them directly in code is a very clean evolution of your current approach and works especially well with global lookups.

Below is a practical, step-by-step way to do it, from simple to more mature setups.

Core idea

Enums remain in code (for type safety & contracts)

Translations live as data (JSON/YAML)

Data artifacts are:

Versioned

Published

Consumed by services and/or UIs at runtime or startup

This decouples:

Translation changes âŸ‚ service releases

Language growth âŸ‚ enum changes

Option 1: Artifact repository (most common & simple)
Structure the lookup data repository

Create a separate repo (or module) just for lookup data:

lookup-data/
â”œâ”€â”€ order-status.yaml
â”œâ”€â”€ country.yaml
â”œâ”€â”€ currency.yaml
â””â”€â”€ i18n/
    â”œâ”€â”€ en.yaml
    â”œâ”€â”€ fr.yaml
    â””â”€â”€ de.yaml


Example (order-status.yaml):

OrderStatus:
  CREATED:
    en: Created
    fr: CrÃ©Ã©
    de: Erstellt
  APPROVED:
    en: Approved
    fr: ApprouvÃ©
    de: Genehmigt


Or per-language:

# en.yaml
OrderStatus.CREATED: Created
OrderStatus.APPROVED: Approved

Publish as a versioned artifact

Package it as:

Maven artifact (zip / jar)

NPM package

OCI artifact

Raw ZIP in Artifactory / Nexus / S3

Example (Maven):

com.example:lookup-data:1.4.0


Contains only:

/lookups/*.yaml

Consume in microservices

At startup:

Load YAML/JSON from classpath or external location

Cache in memory

Provide a lookup API

Example (Spring Boot):

Map<String, String> labels = lookupLoader.load("en");
String label = labels.get("OrderStatus.CREATED");

Pros

âœ… Simple
âœ… Works with any language
âœ… Versioned & traceable
âœ… No runtime dependency

Cons

âŒ Still requires redeploy if you want newer translations

Option 2: Externalized config (Spring Config / Kubernetes)

Store bundles in:

Spring Cloud Config

Kubernetes ConfigMaps

AWS Parameter Store / SSM

Example ConfigMap:

apiVersion: v1
kind: ConfigMap
metadata:
  name: lookup-i18n-en
data:
  OrderStatus.CREATED: Created
  OrderStatus.APPROVED: Approved


Services:

Load at startup

Optionally refresh dynamically

Pros

âœ… No code change
âœ… No rebuild
âœ… Runtime refresh possible

Cons

âŒ Platform-dependent
âŒ Ops complexity

Option 3: Lookup + i18n service (most flexible)

Create a reference data service:

GET /lookups/order-status?lang=en


Response:

{
  "CREATED": "Created",
  "APPROVED": "Approved"
}


Internally:

Stores JSON/YAML

Cached heavily

Versioned

Pros

â­ Runtime updates
â­ Central governance
â­ Perfect for many consumers

Cons

âŒ Extra service
âŒ Needs caching & resiliency

Option 4: Hybrid (best balance for most teams)

What I see work best in practice:

Enums in common library

Lookup bundles as JSON/YAML artifacts

UI consumes directly

Backend optionally consumes for validation

Flow:

lookup-data repo â†’ artifact repo â†’ UI / services

Naming & key strategy (important)

Use stable, code-derived keys:

<EnumName>.<EnumValue>


Example:

OrderStatus.CANCELLED


This allows:

Compile-time enum safety

Runtime data flexibility

Validation safety net (highly recommended)

Add a CI job that:

Parses enum classes

Parses JSON/YAML

Fails build if:

Missing translation

Extra unused keys

Duplicate meanings

This keeps data and code in sync without runtime coupling.

Migration from your current approach

Extract messages_*.properties

Convert to JSON/YAML

Publish as artifact

Load externally instead of classpath

Keep fallback to classpath during transition

Summary
Approach	When to use
Artifact-based JSON/YAML	â­ Most teams
Config-based	Platform-driven systems
Lookup service	Large, multi-client ecosystems

If you want, I can:

Provide a sample Maven + Spring loader

Show a CI validation script

Suggest JSON vs YAML tradeoffs

Just tell me your tech stack and deployment model.

I did not get it exactly. Who uses Lookup bundles as JSON/YAML artifacts. Front end or backend?

Thatâ€™s a very fair question â€” this is the key confusion point, so letâ€™s make it very concrete.

Short, clear answer

Both can use them â€” but the recommended default is:

Frontend uses the JSON/YAML lookup bundles for i18n
Backend uses enums (codes) only

Backend may also load the bundles, but itâ€™s optional.

The mental model (important)

Think of lookup bundles (JSON/YAML) as data, not logic.

Enums = contract

JSON/YAML = presentation

Once you see that split, it becomes clear who should consume what.

Typical and recommended setup (most systems)
Backend (microservices)

Uses:

Enums / codes only

Returns:

{
  "orderStatus": "CANCELLED"
}


Does NOT need:

Translations

Locale-specific text

Why?

Keeps services stateless and simple

Avoids redeployments for wording changes

Prevents UI coupling

Frontend (Web / Mobile / BFF)

Consumes:

JSON lookup bundles (i18n)

One bundle per language

Example:

{
  "OrderStatus.CANCELLED": "Cancelled",
  "OrderStatus.APPROVED": "Approved"
}


Frontend renders:

t("OrderStatus." + orderStatus)


Why frontend is the primary consumer

i18n is a presentation concern

UI can change wording without backend changes

Multiple UIs can share the same bundles

â¡ This is the cleanest separation

When backend also consumes lookup bundles

Backend may load JSON/YAML bundles in these cases only:

1. Backend-generated documents

PDFs

Emails

Reports

Exports (CSV, Excel)

These are presentation outputs, so backend needs labels.

2. Legacy or thin UI

If:

UI is minimal

Backend returns localized responses

Then backend loads bundles and resolves labels.

3. Validation / metadata endpoints

Example:

GET /metadata/order-status?lang=en


Used by UI to bootstrap dropdowns.

Who should NOT own lookup bundles?

âŒ Individual microservices
âŒ Domain-specific services
âŒ Business logic layers

Lookup bundles should be shared data, not service-owned logic.

Concrete architecture diagram (textual)
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚   lookup-data repo  â”‚
          â”‚  (JSON / YAML)      â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚ published as artifact
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Frontend     â”‚       â”‚ Backend (opt.) â”‚
â”‚  i18n runtime  â”‚       â”‚ PDFs / emails  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Backend microservices                    â”‚
â”‚  - enums only                            â”‚
â”‚  - return codes                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Alternative: Backend-first localization (less recommended)

If you choose backend localization:

Backend loads JSON/YAML

Backend returns:

{
  "orderStatus": {
    "code": "CANCELLED",
    "label": "Cancelled"
  }
}


Frontend:

Just displays text

This works â€” but you lose flexibility and independence.

Final rule of thumb
Component	Uses enums	Uses lookup bundles
Backend core logic	âœ…	âŒ
Backend docs / exports	âœ…	âœ…
Frontend	âŒ	âœ…
Lookup / metadata service	âŒ	âœ…
Bottom line

Lookup bundles as JSON/YAML are primarily for the frontend.
Backend should mostly deal in codes, not translations.

If you want, I can:

Show a real folder structure (monorepo vs multi-repo)

Give a sample frontend i18n setup

Show a BFF-based variant

Just tell me your UI stack (React, Angular, Vue, etc.).

Show me all React

Perfect â€” letâ€™s make this 100% concrete with React.
Iâ€™ll show you exactly how React uses lookup bundles (JSON) for enums coming from backend microservices, end-to-end.

React + Backend Enums + JSON Lookup Bundles
1ï¸âƒ£ What backend sends (codes only)

Backend response:

{
  "orderId": "123",
  "status": "CANCELLED",
  "paymentMethod": "CARD"
}


Backend contract:

Stable enum codes

No translations

2ï¸âƒ£ Lookup bundles (JSON artifacts)
Folder structure
lookup-data/
â”œâ”€â”€ en.json
â”œâ”€â”€ fr.json
â””â”€â”€ de.json

en.json
{
  "OrderStatus.CREATED": "Created",
  "OrderStatus.APPROVED": "Approved",
  "OrderStatus.CANCELLED": "Cancelled",

  "PaymentMethod.CARD": "Card",
  "PaymentMethod.CASH": "Cash"
}

fr.json
{
  "OrderStatus.CREATED": "CrÃ©Ã©",
  "OrderStatus.APPROVED": "ApprouvÃ©",
  "OrderStatus.CANCELLED": "AnnulÃ©",

  "PaymentMethod.CARD": "Carte",
  "PaymentMethod.CASH": "EspÃ¨ces"
}


These JSON files are:

Stored in a repo

Published as an artifact

Or hosted via CDN

3ï¸âƒ£ Install React i18n tooling

Using react-i18next (recommended):

npm install i18next react-i18next

4ï¸âƒ£ Initialize i18n in React
i18n.ts
import i18n from "i18next";
import { initReactI18next } from "react-i18next";

import en from "./i18n/en.json";
import fr from "./i18n/fr.json";

i18n
  .use(initReactI18next)
  .init({
    resources: {
      en: { translation: en },
      fr: { translation: fr }
    },
    lng: "en",
    fallbackLng: "en",
    interpolation: {
      escapeValue: false
    }
  });

export default i18n;

Load once in main.tsx
import "./i18n";

5ï¸âƒ£ Rendering enum values in React
Utility function (important)
export function lookup(enumName: string, value: string) {
  return `${enumName}.${value}`;
}

React component
import { useTranslation } from "react-i18next";
import { lookup } from "./lookup";

function OrderRow({ order }: { order: any }) {
  const { t } = useTranslation();

  return (
    <div>
      <span>Status: {t(lookup("OrderStatus", order.status))}</span>
      <span>Payment: {t(lookup("PaymentMethod", order.paymentMethod))}</span>
    </div>
  );
}

6ï¸âƒ£ Dropdowns / Selects (very common use case)
Metadata endpoint (optional)
GET /metadata/order-status


Backend response:

["CREATED", "APPROVED", "CANCELLED"]

React dropdown
const ORDER_STATUSES = ["CREATED", "APPROVED", "CANCELLED"];

function OrderStatusSelect({ value, onChange }: any) {
  const { t } = useTranslation();

  return (
    <select value={value} onChange={e => onChange(e.target.value)}>
      {ORDER_STATUSES.map(status => (
        <option key={status} value={status}>
          {t(`OrderStatus.${status}`)}
        </option>
      ))}
    </select>
  );
}

7ï¸âƒ£ Lazy-load bundles (CDN / runtime)

If bundles are hosted remotely:

i18n
  .use(HttpBackend)
  .init({
    backend: {
      loadPath: "/i18n/{{lng}}.json"
    }
  });


This allows:

Translation updates without redeploy

Multiple apps sharing same bundles

8ï¸âƒ£ Fallback safety (important!)
{
  "OrderStatus.UNKNOWN": "Unknown"
}


And in React:

t(`OrderStatus.${status}`, status);


If missing â†’ shows raw code.

9ï¸âƒ£ Type safety (optional but recommended)
Shared enum types (generated)
export type OrderStatus =
  | "CREATED"
  | "APPROVED"
  | "CANCELLED";


Or generate from OpenAPI.

ğŸ”Ÿ What React owns vs Backend owns
Concern	Backend	React
Enum values	âœ…	âŒ
Translations	âŒ	âœ…
Language switching	âŒ	âœ…
Label wording	âŒ	âœ…
âœ… Final takeaway

React is the primary consumer of JSON lookup bundles.
Backend stays clean and returns codes only.

This gives you:

Decoupled microservices

Zero backend redeploy for translation changes

Consistent labels across all UIs

If you want next:

Monorepo structure

CI validation of enum â†” JSON

OpenAPI â†’ enum â†’ i18n generation

Just tell me ğŸ‘

show all

Got it â€” you want everything, end-to-end, in one complete React example, with no gaps.

Below is a full, realistic setup showing:

Backend â†’ enum codes

Lookup bundles as JSON artifacts

React app consuming them

i18n setup

Dropdowns, tables, fallbacks

Optional runtime loading

âœ… COMPLETE React i18n Lookup Setup (End-to-End)
0ï¸âƒ£ Architecture (one glance)
Backend (microservices)
  â””â”€â”€ returns enum CODES only

Lookup Data (JSON artifacts / CDN / repo)
  â””â”€â”€ en.json, fr.json, de.json

React App
  â”œâ”€â”€ loads JSON bundles
  â”œâ”€â”€ maps enum â†’ label
  â””â”€â”€ renders UI

1ï¸âƒ£ Backend contract (what React receives)

Backend response:

{
  "orderId": "A123",
  "status": "CANCELLED",
  "paymentMethod": "CARD"
}


Backend enums (Java / .NET / etc.):

enum OrderStatus {
  CREATED,
  APPROVED,
  CANCELLED
}


â— Backend never sends translated text

2ï¸âƒ£ Lookup bundles (JSON data artifacts)
Folder (shared repo or CDN)
lookup-data/
â””â”€â”€ i18n/
    â”œâ”€â”€ en.json
    â”œâ”€â”€ fr.json
    â””â”€â”€ de.json

en.json
{
  "OrderStatus.CREATED": "Created",
  "OrderStatus.APPROVED": "Approved",
  "OrderStatus.CANCELLED": "Cancelled",

  "PaymentMethod.CARD": "Card",
  "PaymentMethod.CASH": "Cash",

  "common.unknown": "Unknown"
}

fr.json
{
  "OrderStatus.CREATED": "CrÃ©Ã©",
  "OrderStatus.APPROVED": "ApprouvÃ©",
  "OrderStatus.CANCELLED": "AnnulÃ©",

  "PaymentMethod.CARD": "Carte",
  "PaymentMethod.CASH": "EspÃ¨ces",

  "common.unknown": "Inconnu"
}


These files:

Are not code

Can be updated independently

Can be shared by multiple UIs

3ï¸âƒ£ React app structure
src/
â”œâ”€â”€ api/
â”‚   â””â”€â”€ orders.ts
â”œâ”€â”€ i18n/
â”‚   â”œâ”€â”€ en.json
â”‚   â”œâ”€â”€ fr.json
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ lookup/
â”‚   â””â”€â”€ lookup.ts
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ OrderRow.tsx
â”‚   â””â”€â”€ OrderStatusSelect.tsx
â”œâ”€â”€ App.tsx
â””â”€â”€ main.tsx

4ï¸âƒ£ Install dependencies
npm install i18next react-i18next

5ï¸âƒ£ i18n initialization (React)
src/i18n/index.ts
import i18n from "i18next";
import { initReactI18next } from "react-i18next";

import en from "./en.json";
import fr from "./fr.json";

i18n
  .use(initReactI18next)
  .init({
    resources: {
      en: { translation: en },
      fr: { translation: fr }
    },
    lng: "en",
    fallbackLng: "en",
    interpolation: {
      escapeValue: false
    }
  });

export default i18n;

src/main.tsx
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./i18n";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

6ï¸âƒ£ Lookup helper (IMPORTANT)
src/lookup/lookup.ts
export function lookup(enumName: string, value?: string) {
  if (!value) return "common.unknown";
  return `${enumName}.${value}`;
}

7ï¸âƒ£ API simulation (backend call)
src/api/orders.ts
export type Order = {
  orderId: string;
  status: "CREATED" | "APPROVED" | "CANCELLED";
  paymentMethod: "CARD" | "CASH";
};

export function fetchOrder(): Promise<Order> {
  return Promise.resolve({
    orderId: "A123",
    status: "CANCELLED",
    paymentMethod: "CARD"
  });
}

8ï¸âƒ£ Render enum labels in React
src/components/OrderRow.tsx
import { useTranslation } from "react-i18next";
import { lookup } from "../lookup/lookup";
import { Order } from "../api/orders";

export function OrderRow({ order }: { order: Order }) {
  const { t } = useTranslation();

  return (
    <div>
      <div>
        Status: {t(lookup("OrderStatus", order.status))}
      </div>
      <div>
        Payment: {t(lookup("PaymentMethod", order.paymentMethod))}
      </div>
    </div>
  );
}

9ï¸âƒ£ Dropdowns from enums (very common)
src/components/OrderStatusSelect.tsx
import { useTranslation } from "react-i18next";
import { lookup } from "../lookup/lookup";

const STATUSES = ["CREATED", "APPROVED", "CANCELLED"] as const;

export function OrderStatusSelect({
  value,
  onChange
}: {
  value: string;
  onChange: (v: string) => void;
}) {
  const { t } = useTranslation();

  return (
    <select value={value} onChange={e => onChange(e.target.value)}>
      {STATUSES.map(status => (
        <option key={status} value={status}>
          {t(lookup("OrderStatus", status))}
        </option>
      ))}
    </select>
  );
}

ğŸ”Ÿ Language switcher
src/App.tsx
import { useEffect, useState } from "react";
import { useTranslation } from "react-i18next";
import { fetchOrder, Order } from "./api/orders";
import { OrderRow } from "./components/OrderRow";

export default function App() {
  const { i18n } = useTranslation();
  const [order, setOrder] = useState<Order | null>(null);

  useEffect(() => {
    fetchOrder().then(setOrder);
  }, []);

  return (
    <div>
      <button onClick={() => i18n.changeLanguage("en")}>EN</button>
      <button onClick={() => i18n.changeLanguage("fr")}>FR</button>

      {order && <OrderRow order={order} />}
    </div>
  );
}

1ï¸âƒ£1ï¸âƒ£ Runtime loading from CDN (optional)

If bundles live on CDN instead of being bundled:

import HttpBackend from "i18next-http-backend";

i18n
  .use(HttpBackend)
  .use(initReactI18next)
  .init({
    backend: {
      loadPath: "/i18n/{{lng}}.json"
    }
  });


â¡ Change translations without redeploying React

1ï¸âƒ£2ï¸âƒ£ Validation (highly recommended)

CI rule:

Every enum value must exist in JSON

No unused keys allowed

This keeps enum â†” translation alignment without runtime coupling.

âœ… FINAL SUMMARY
Who uses what?
Layer	Uses enums	Uses JSON bundles
Backend	âœ…	âŒ
React UI	âŒ	âœ…
Docs / PDFs backend	âœ…	âœ…
Why this is the best setup

âœ” Microservices stay decoupled
âœ” i18n changes donâ€™t require backend redeploy
âœ” React controls presentation
âœ” Enum meaning stays global and stable

If you want next, I can show:

Monorepo layout

OpenAPI â†’ enum â†’ JSON generation

CI validation scripts

BFF variant

Just say the word.

OpenAPI â†’ enum â†’ JSON generation

Perfect â€” this is the missing automation piece that makes the whole approach robust.

Below is a complete, real-world pipeline for:

OpenAPI â†’ enums â†’ i18n JSON (lookup bundles)

Iâ€™ll show:

OpenAPI definition

Enum generation

JSON lookup generation

CI validation

How React consumes the result

1ï¸âƒ£ OpenAPI: the source of truth

Your backend owns enum codes, and they are exposed via OpenAPI.

openapi.yaml
openapi: 3.0.3
info:
  title: Order API
  version: 1.0.0

components:
  schemas:
    OrderStatus:
      type: string
      enum:
        - CREATED
        - APPROVED
        - CANCELLED

    PaymentMethod:
      type: string
      enum:
        - CARD
        - CASH


ğŸ“Œ Rule

Enum names + values are stable

No localization here

This is the canonical contract

2ï¸âƒ£ Generate enums from OpenAPI
Option A: Frontend (TypeScript) â€” most common
Install OpenAPI Generator
npm install @openapitools/openapi-generator-cli --save-dev

Generate types
npx openapi-generator-cli generate \
  -i openapi.yaml \
  -g typescript-fetch \
  -o generated/api

Result (simplified)
export enum OrderStatus {
  Created = "CREATED",
  Approved = "APPROVED",
  Cancelled = "CANCELLED"
}


â¡ React now has type-safe enum values

Option B: Backend (Java example)
public enum OrderStatus {
  CREATED,
  APPROVED,
  CANCELLED
}


(OpenAPI can be generated from backend too â€” either direction works.)

3ï¸âƒ£ Generate i18n JSON from enums (KEY STEP)

Now we generate lookup JSON skeletons automatically.

Strategy

Parse OpenAPI (or generated enums)

Produce:

en.json

fr.json

With keys only

Human translators fill labels later

Example generator (Node.js)
scripts/generate-lookups.js
import fs from "fs";
import yaml from "js-yaml";

const openapi = yaml.load(fs.readFileSync("openapi.yaml", "utf8"));

const schemas = openapi.components.schemas;
const result = {};

for (const [schemaName, schema] of Object.entries(schemas)) {
  if (schema.enum) {
    schema.enum.forEach(value => {
      result[`${schemaName}.${value}`] = value; // default label
    });
  }
}

fs.writeFileSync(
  "lookup-data/en.json",
  JSON.stringify(result, null, 2)
);

Output (en.json)
{
  "OrderStatus.CREATED": "CREATED",
  "OrderStatus.APPROVED": "APPROVED",
  "OrderStatus.CANCELLED": "CANCELLED",
  "PaymentMethod.CARD": "CARD",
  "PaymentMethod.CASH": "CASH"
}


â¡ This guarantees 100% enum coverage

4ï¸âƒ£ Translation workflow

Now you have a clean flow:

OpenAPI
  â†“
Enum codes
  â†“
Generated JSON keys
  â†“
Human translation


Example after translation:

{
  "OrderStatus.CREATED": "Created",
  "OrderStatus.APPROVED": "Approved",
  "OrderStatus.CANCELLED": "Cancelled",
  "PaymentMethod.CARD": "Card",
  "PaymentMethod.CASH": "Cash"
}

5ï¸âƒ£ CI validation (CRITICAL)

This prevents drift.

What CI checks

âœ” Every enum value exists in JSON
âœ” No extra keys in JSON
âœ” No missing translations

Example validation script
const translations = JSON.parse(fs.readFileSync("en.json"));
const expectedKeys = Object.keys(result); // from OpenAPI

expectedKeys.forEach(key => {
  if (!translations[key]) {
    throw new Error(`Missing translation for ${key}`);
  }
});


Fail build if:

Enum added but translation missing

Translation key doesnâ€™t match enum

6ï¸âƒ£ Publishing artifacts

You now publish two independent artifacts:

Backend artifact

OpenAPI

Enums

Versioned APIs

Lookup artifact

en.json

fr.json

de.json

Published to:

CDN

NPM package

S3

Artifactory

7ï¸âƒ£ React consumption (final step)

React does not care about OpenAPI anymore.

t(`OrderStatus.${order.status}`)


Everything just works because:

Keys are generated

Types are enforced

CI prevents mismatch

8ï¸âƒ£ Optional: full automation flow
Backend PR
 â”œâ”€ Add enum value
 â”œâ”€ OpenAPI updated
 â”œâ”€ CI generates lookup JSON
 â”œâ”€ CI fails until translations added
 â””â”€ Merge â†’ publish artifacts


This is enterprise-grade i18n without runtime coupling.

âœ… Final mental model
Layer	Responsibility
OpenAPI	Canonical enum definitions
Backend	Business logic & codes
Generator	Keys & skeleton JSON
Humans	Translation text
React	Rendering
If you want next (advanced)

I can show:

Java-based generator

OpenAPI â†’ React enums + i18n in one step

Monorepo automation

Multi-tenant overrides

Just tell me which one.

How about BFF variant

Great question. A BFF (Backend-for-Frontend) fits very naturally with your global enums + JSON lookup bundles approach.
Iâ€™ll walk you through it cleanly and end-to-end, and Iâ€™ll be very explicit about who does what.

BFF Variant â€” End-to-End
1ï¸âƒ£ What problem the BFF solves (in your case)

A BFF is ideal when you want:

Backend microservices to stay pure (codes only)

Frontend to stay simple

Centralized handling of:

i18n

lookup metadata

aggregation

formatting

With a BFF, React never talks to microservices directly.

2ï¸âƒ£ High-level architecture
Microservices
  â””â”€â”€ return enum CODES only

Lookup Data (JSON/YAML)
  â””â”€â”€ global reference data

BFF
  â”œâ”€â”€ aggregates APIs
  â”œâ”€â”€ loads lookup bundles
  â”œâ”€â”€ resolves labels (optional)
  â””â”€â”€ exposes UI-friendly endpoints

React
  â””â”€â”€ talks only to BFF

3ï¸âƒ£ Two BFF styles (important choice)
ğŸ”¹ Style A â€” Code-first BFF (recommended)

BFF returns codes, React does i18n.

ğŸ”¹ Style B â€” Label-resolving BFF

BFF returns both code + label.

Iâ€™ll show both, then tell you which one to choose.

Style A â€” Code-First BFF â­ (Recommended)
Backend microservices
{
  "status": "CANCELLED",
  "paymentMethod": "CARD"
}

BFF response
{
  "status": "CANCELLED",
  "paymentMethod": "CARD"
}


BFF responsibilities:

API aggregation

Authorization

Shaping data

âŒ No localization

React

Loads JSON lookup bundles

Resolves labels

t(`OrderStatus.${order.status}`)

Why this is best

âœ” Clean separation
âœ” No locale logic in backend
âœ” Easy to add languages
âœ” Zero backend redeploy for wording changes

Style B â€” Label-Resolving BFF (When Needed)

Use this only if:

You generate PDFs / emails

You have multiple thin clients

You want one â€œsource of presentation truthâ€

BFF loads lookup bundles

At startup:

const lookups = loadJson("en.json");

BFF response
{
  "status": {
    "code": "CANCELLED",
    "label": "Cancelled"
  },
  "paymentMethod": {
    "code": "CARD",
    "label": "Card"
  }
}

React (very thin)
<span>{order.status.label}</span>

Trade-offs

âŒ Locale awareness in backend
âŒ Harder caching
âŒ Less UI flexibility

4ï¸âƒ£ BFF exposing lookup metadata (very useful)

Regardless of style, BFF is the perfect place to expose lookup endpoints.

Endpoint
GET /ui/lookups/order-status?lang=en

Response
[
  { "code": "CREATED", "label": "Created" },
  { "code": "APPROVED", "label": "Approved" },
  { "code": "CANCELLED", "label": "Cancelled" }
]


React uses this for:

Dropdowns

Filters

Forms

5ï¸âƒ£ How BFF uses JSON lookup artifacts
Startup flow
BFF starts
 â”œâ”€ loads en.json, fr.json
 â”œâ”€ caches in memory
 â””â”€ exposes lookup APIs

Runtime

Locale from HTTP header (Accept-Language)

Fallback language supported

Strong caching

6ï¸âƒ£ OpenAPI â†’ BFF â†’ React (complete flow)
Microservice OpenAPI
  â†“
Enum codes
  â†“
Lookup JSON generation
  â†“
BFF loads lookup bundles
  â†“
React consumes via BFF or directly

7ï¸âƒ£ Folder structure (Node.js BFF example)
bff/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lookups/
â”‚   â”‚   â”œâ”€â”€ en.json
â”‚   â”‚   â”œâ”€â”€ fr.json
â”‚   â”‚   â””â”€â”€ loader.ts
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ orders.ts
â”‚   â”‚   â””â”€â”€ lookups.ts
â”‚   â””â”€â”€ app.ts

8ï¸âƒ£ Lookup loader (Node.js example)
export function lookup(enumName: string, value: string, lang = "en") {
  return lookups[lang]?.[`${enumName}.${value}`] ?? value;
}

9ï¸âƒ£ Decision table (IMPORTANT)
Question	If YES	If NO
Do you want UI control over wording?	Style A	Style B
Multiple UI clients?	Style A	Style B
PDFs / emails?	Style B	Style A
Frequent wording changes?	Style A	Style B
âœ… Final Recommendation (for your case)

Based on everything youâ€™ve said:

Global enums

Microservices

React UI

Shared lookup data

ğŸ‘‰ Use a Code-First BFF (Style A)

Let:

Microservices â†’ codes

BFF â†’ aggregation only

React â†’ JSON lookup bundles

If you want next, I can show:

BFF + React combined example

Spring Boot BFF

Caching strategies

Multi-tenant overrides

Just tell me which one.

Spring boot BFF

Great â€” here is a clean, production-grade Spring Boot BFF design that fits your global enums + JSON lookup bundles + React UI model.

Iâ€™ll show:

Architecture & responsibilities

Spring Boot BFF project structure

Loading lookup JSON artifacts

Aggregating microservices

Lookup endpoints for React

Locale handling

Caching & best practices

1ï¸âƒ£ Architecture (Spring Boot BFF)
Microservices
  â””â”€â”€ return enum CODES only

Lookup Data (JSON artifacts / CDN / classpath)
  â””â”€â”€ en.json, fr.json

Spring Boot BFF
  â”œâ”€â”€ API aggregation
  â”œâ”€â”€ Security / auth
  â”œâ”€â”€ Lookup metadata endpoints
  â””â”€â”€ (Optional) label resolution

React
  â””â”€â”€ talks ONLY to BFF


ğŸ“Œ Golden rule

Microservices â†’ codes
BFF â†’ orchestration
UI â†’ presentation (i18n)

2ï¸âƒ£ Spring Boot BFF project structure
bff/
â”œâ”€â”€ src/main/java/com/example/bff
â”‚   â”œâ”€â”€ BffApplication.java
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”œâ”€â”€ WebClientConfig.java
â”‚   â”‚   â””â”€â”€ LocaleConfig.java
â”‚   â”œâ”€â”€ lookup/
â”‚   â”‚   â”œâ”€â”€ LookupService.java
â”‚   â”‚   â””â”€â”€ LookupLoader.java
â”‚   â”œâ”€â”€ controller/
â”‚   â”‚   â”œâ”€â”€ OrderController.java
â”‚   â”‚   â””â”€â”€ LookupController.java
â”‚   â””â”€â”€ client/
â”‚       â””â”€â”€ OrderServiceClient.java
â”‚
â”œâ”€â”€ src/main/resources
â”‚   â””â”€â”€ lookups/
â”‚       â”œâ”€â”€ en.json
â”‚       â””â”€â”€ fr.json

3ï¸âƒ£ Lookup JSON artifacts
src/main/resources/lookups/en.json
{
  "OrderStatus.CREATED": "Created",
  "OrderStatus.APPROVED": "Approved",
  "OrderStatus.CANCELLED": "Cancelled"
}


(These may also be loaded from external path / S3 / CDN.)

4ï¸âƒ£ Loading lookup bundles in Spring Boot
LookupLoader.java
@Component
public class LookupLoader {

    private final ObjectMapper objectMapper;
    private final Map<String, Map<String, String>> cache = new ConcurrentHashMap<>();

    public LookupLoader(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @PostConstruct
    public void load() throws IOException {
        loadLanguage("en");
        loadLanguage("fr");
    }

    private void loadLanguage(String lang) throws IOException {
        String path = "lookups/" + lang + ".json";
        InputStream is = new ClassPathResource(path).getInputStream();
        Map<String, String> data =
            objectMapper.readValue(is, new TypeReference<>() {});
        cache.put(lang, data);
    }

    public Map<String, String> get(String lang) {
        return cache.getOrDefault(lang, cache.get("en"));
    }
}

5ï¸âƒ£ Lookup service (safe access)
LookupService.java
@Service
public class LookupService {

    private final LookupLoader loader;

    public LookupService(LookupLoader loader) {
        this.loader = loader;
    }

    public String label(String enumName, String value, String lang) {
        String key = enumName + "." + value;
        return loader.get(lang).getOrDefault(key, value);
    }

    public List<LookupItem> list(String enumName,

use springboot 4 jackson 3 and java 25 

Great â€” below is a complete Spring Boot BFF example using your requested stack:

Spring Boot 4

Jackson 3

Java 25

BFF style (Code-first, React-friendly)

Global enums + JSON lookup bundles

Clean separation (microservices â†’ codes, BFF â†’ aggregation + optional lookup APIs)

Iâ€™ll keep it practical, copy-pasteable, and opinionated.

1ï¸âƒ£ What this Spring Boot BFF does

âœ… Calls downstream microservices
âœ… Returns enum codes only for normal APIs
âœ… Optionally exposes UI lookup endpoints
âœ… Loads JSON lookup bundles (generated from OpenAPI)
âŒ Does not mix business logic with localization

2ï¸âƒ£ Project structure
bff/
â”œâ”€â”€ src/main/java
â”‚   â””â”€â”€ com.example.bff
â”‚       â”œâ”€â”€ BffApplication.java
â”‚       â”œâ”€â”€ config/
â”‚       â”‚   â””â”€â”€ JacksonConfig.java
â”‚       â”œâ”€â”€ lookup/
â”‚       â”‚   â”œâ”€â”€ LookupService.java
â”‚       â”‚   â””â”€â”€ LookupController.java
â”‚       â”œâ”€â”€ orders/
â”‚       â”‚   â”œâ”€â”€ OrderClient.java
â”‚       â”‚   â”œâ”€â”€ OrderController.java
â”‚       â”‚   â””â”€â”€ OrderDto.java
â”‚
â”œâ”€â”€ src/main/resources
â”‚   â””â”€â”€ lookups/
â”‚       â”œâ”€â”€ en.json
â”‚       â””â”€â”€ fr.json
â””â”€â”€ build.gradle

3ï¸âƒ£ Lookup JSON bundles (data artifacts)
src/main/resources/lookups/en.json
{
  "OrderStatus.CREATED": "Created",
  "OrderStatus.APPROVED": "Approved",
  "OrderStatus.CANCELLED": "Cancelled",

  "PaymentMethod.CARD": "Card",
  "PaymentMethod.CASH": "Cash"
}

fr.json
{
  "OrderStatus.CREATED": "CrÃ©Ã©",
  "OrderStatus.APPROVED": "ApprouvÃ©",
  "OrderStatus.CANCELLED": "AnnulÃ©",

  "PaymentMethod.CARD": "Carte",
  "PaymentMethod.CASH": "EspÃ¨ces"
}


These files are generated + translated, not handwritten in code.

4ï¸âƒ£ Jackson 3 configuration (Spring Boot 4)
JacksonConfig.java
package com.example.bff.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.json.JsonMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class JacksonConfig {

    @Bean
    ObjectMapper objectMapper() {
        return JsonMapper.builder()
                .findAndAddModules()
                .build();
    }
}


âœ” Jackson 3
âœ” Java 25 compatible
âœ” Records supported

5ï¸âƒ£ LookupService (core piece)

This loads JSON bundles once and serves lookups efficiently.

LookupService.java
package com.example.bff.lookup;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.stereotype.Service;

import java.io.InputStream;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class LookupService {

    private final ObjectMapper objectMapper;
    private final Map<String, Map<String, String>> cache = new ConcurrentHashMap<>();

    public LookupService(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    public String label(String enumName, String code, String lang) {
        var map = cache.computeIfAbsent(lang, this::load);
        return map.getOrDefault(enumName + "." + code, code);
    }

    public Map<String, String> all(String lang) {
        return cache.computeIfAbsent(lang, this::load);
    }

    private Map<String, String> load(String lang) {
        try (InputStream is =
                     getClass().getResourceAsStream("/lookups/" + lang + ".json")) {

            if (is == null) {
                throw new IllegalStateException("Missing lookup bundle: " + lang);
            }

            return objectMapper.readValue(is, new TypeReference<>() {});
        } catch (Exception e) {
            throw new RuntimeException("Failed to load lookups for " + lang, e);
        }
    }
}


âœ” Thread-safe
âœ” Cached
âœ” Language fallback-ready

6ï¸âƒ£ LookupController (UI metadata endpoint)

This is extremely useful for React dropdowns.

LookupController.java
package com.example.bff.lookup;

import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/ui/lookups")
public class LookupController {

    private final LookupService lookupService;

    public LookupController(LookupService lookupService) {
        this.lookupService = lookupService;
    }

    @GetMapping("/{enumName}")
    public List<LookupItem> lookup(
            @PathVariable String enumName,
            @RequestHeader(name = "Accept-Language", defaultValue = "en") String lang
    ) {
        return lookupService.all(lang).entrySet().stream()
                .filter(e -> e.getKey().startsWith(enumName + "."))
                .map(e -> new LookupItem(
                        e.getKey().substring(enumName.length() + 1),
                        e.getValue()
                ))
                .toList();
    }

    public record LookupItem(String code, String label) {}
}

Example response
[
  { "code": "CREATED", "label": "Created" },
  { "code": "APPROVED", "label": "Approved" }
]

7ï¸âƒ£ Order DTO (codes only!)
OrderDto.java
package com.example.bff.orders;

public record OrderDto(
        String orderId,
        String status,
        String paymentMethod
) {}


No localization here. Codes only.

8ï¸âƒ£ Downstream microservice client (example)
OrderClient.java
package com.example.bff.orders;

import org.springframework.stereotype.Component;
import org.springframework.web.client.RestClient;

@Component
public class OrderClient {

    private final RestClient restClient = RestClient.create();

    public OrderDto getOrder(String id) {
        return restClient.get()
                .uri("http://orders-service/orders/{id}", id)
                .retrieve()
                .body(OrderDto.class);
    }
}

9ï¸âƒ£ OrderController (BFF API)
OrderController.java
package com.example.bff.orders;

import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/ui/orders")
public class OrderController {

    private final OrderClient client;

    public OrderController(OrderClient client) {
        this.client = client;
    }

    @GetMapping("/{id}")
    public OrderDto getOrder(@PathVariable String id) {
        return client.getOrder(id);
    }
}


âœ” No localization
âœ” No enum interpretation
âœ” Clean BFF boundary

ğŸ”Ÿ How React uses this BFF
API calls
GET /ui/orders/123
GET /ui/lookups/OrderStatus

React rendering
t(`OrderStatus.${order.status}`)


OR dropdown from BFF:

<select>
  {lookups.map(l =>
    <option key={l.code}>{l.label}</option>
  )}
</select>

1ï¸âƒ£1ï¸âƒ£ Why this design is correct

âœ” Spring Boot BFF stays presentation-aware but logic-free
âœ” Microservices remain pure domain services
âœ” i18n can change without redeploying microservices
âœ” Lookup data is generated, validated, versioned
âœ” React stays simple

âœ… Final Recommendation

For Spring Boot 4 + Jackson 3 + Java 25:

Microservices â†’ enums + OpenAPI

Generated JSON lookup bundles â†’ shared artifacts

Spring Boot BFF â†’ aggregation + lookup metadata

React â†’ rendering + language switching

If you want next, I can show:

Spring Boot BFF resolving labels (Style B)

Caching + ETag

Multi-tenant overrides

CI validation against OpenAPI

Just say which one.

show me all

Perfect â€” you want a full, end-to-end setup, combining everything we discussed:

Microservices with OpenAPI enums

JSON lookup bundles (generated)

Spring Boot 4 BFF using Jackson 3 and Java 25

React frontend consuming the BFF

i18n fully supported

Optional dropdowns, tables, language switching

Iâ€™ll give you a complete working blueprint you can copy/paste and extend.

1ï¸âƒ£ Microservices (source of truth)
openapi.yaml
openapi: 3.0.3
info:
  title: Order Service API
  version: 1.0.0

components:
  schemas:
    OrderStatus:
      type: string
      enum:
        - CREATED
        - APPROVED
        - CANCELLED
    PaymentMethod:
      type: string
      enum:
        - CARD
        - CASH

paths:
  /orders/{id}:
    get:
      summary: Get order by ID
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Success
          content:
            application/json:
              schema:
                type: object
                properties:
                  orderId:
                    type: string
                  status:
                    $ref: '#/components/schemas/OrderStatus'
                  paymentMethod:
                    $ref: '#/components/schemas/PaymentMethod'

2ï¸âƒ£ Generate enums â†’ JSON skeletons
Node.js generator (scripts/generate-lookups.js)
import fs from "fs";
import yaml from "js-yaml";

const openapi = yaml.load(fs.readFileSync("openapi.yaml", "utf8"));

const schemas = openapi.components.schemas;
const result = {};

for (const [schemaName, schema] of Object.entries(schemas)) {
  if (schema.enum) {
    schema.enum.forEach(value => {
      result[`${schemaName}.${value}`] = value;
    });
  }
}

fs.writeFileSync("lookup-data/en.json", JSON.stringify(result, null, 2));
fs.writeFileSync("lookup-data/fr.json", JSON.stringify(result, null, 2));
console.log("Lookup skeletons generated.");

Output (en.json)
{
  "OrderStatus.CREATED": "CREATED",
  "OrderStatus.APPROVED": "APPROVED",
  "OrderStatus.CANCELLED": "CANCELLED",
  "PaymentMethod.CARD": "CARD",
  "PaymentMethod.CASH": "CASH"
}


âœ… Translators fill in labels.

3ï¸âƒ£ Spring Boot 4 BFF
build.gradle dependencies
plugins {
    id 'java'
    id 'org.springframework.boot' version '4.0.0'
}

java {
    sourceCompatibility = JavaVersion.VERSION_25
    targetCompatibility = JavaVersion.VERSION_25
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'com.fasterxml.jackson.core:jackson-databind:3.1.0'
}

BffApplication.java
package com.example.bff;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BffApplication {
    public static void main(String[] args) {
        SpringApplication.run(BffApplication.class, args);
    }
}

JacksonConfig.java
package com.example.bff.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.json.JsonMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class JacksonConfig {
    @Bean
    public ObjectMapper objectMapper() {
        return JsonMapper.builder().findAndAddModules().build();
    }
}

LookupService.java
package com.example.bff.lookup;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.stereotype.Service;

import java.io.InputStream;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class LookupService {

    private final ObjectMapper objectMapper;
    private final Map<String, Map<String, String>> cache = new ConcurrentHashMap<>();

    public LookupService(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    public String label(String enumName, String code, String lang) {
        var map = cache.computeIfAbsent(lang, this::load);
        return map.getOrDefault(enumName + "." + code, code);
    }

    public Map<String, String> all(String lang) {
        return cache.computeIfAbsent(lang, this::load);
    }

    private Map<String, String> load(String lang) {
        try (InputStream is =
                     getClass().getResourceAsStream("/lookups/" + lang + ".json")) {
            if (is == null) throw new IllegalStateException("Missing lookup bundle: " + lang);
            return objectMapper.readValue(is, new TypeReference<>() {});
        } catch (Exception e) {
            throw new RuntimeException("Failed to load lookups for " + lang, e);
        }
    }
}

LookupController.java
package com.example.bff.lookup;

import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/ui/lookups")
public class LookupController {

    private final LookupService lookupService;

    public LookupController(LookupService lookupService) {
        this.lookupService = lookupService;
    }

    @GetMapping("/{enumName}")
    public List<LookupItem> lookup(
            @PathVariable String enumName,
            @RequestHeader(name = "Accept-Language", defaultValue = "en") String lang
    ) {
        return lookupService.all(lang).entrySet().stream()
                .filter(e -> e.getKey().startsWith(enumName + "."))
                .map(e -> new LookupItem(
                        e.getKey().substring(enumName.length() + 1),
                        e.getValue()
                ))
                .toList();
    }

    public record LookupItem(String code, String label) {}
}

OrderDto.java
package com.example.bff.orders;

public record OrderDto(String orderId, String status, String paymentMethod) {}

OrderClient.java (example downstream call)
package com.example.bff.orders;

import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

@Component
public class OrderClient {

    private final RestTemplate restTemplate = new RestTemplate();

    public OrderDto getOrder(String id) {
        return restTemplate.getForObject(
                "http://orders-service/orders/{id}", OrderDto.class, id
        );
    }
}

OrderController.java
package com.example.bff.orders;

import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/ui/orders")
public class OrderController {

    private final OrderClient client;

    public OrderController(OrderClient client) {
        this.client = client;
    }

    @GetMapping("/{id}")
    public OrderDto getOrder(@PathVariable String id) {
        return client.getOrder(id);
    }
}

4ï¸âƒ£ React frontend
Folder structure
src/
â”œâ”€ i18n/
â”‚  â”œâ”€ en.json
â”‚  â””â”€ fr.json
â”œâ”€ lookup/
â”‚  â””â”€ lookup.ts
â”œâ”€ api/
â”‚  â””â”€ orders.ts
â”œâ”€ components/
â”‚  â”œâ”€ OrderRow.tsx
â”‚  â””â”€ OrderStatusSelect.tsx
â””â”€ App.tsx

lookup.ts
export function lookup(enumName: string, value?: string) {
  return value ? `${enumName}.${value}` : "common.unknown";
}

api/orders.ts
export type Order = {
  orderId: string;
  status: "CREATED" | "APPROVED" | "CANCELLED";
  paymentMethod: "CARD" | "CASH";
};

export async function fetchOrder(): Promise<Order> {
  const res = await fetch("/ui/orders/A123");
  return res.json();
}

OrderRow.tsx
import { useTranslation } from "react-i18next";
import { lookup } from "../lookup/lookup";
import { Order } from "../api/orders";

export function OrderRow({ order }: { order: Order }) {
  const { t } = useTranslation();

  return (
    <div>
      <div>Status: {t(lookup("OrderStatus", order.status))}</div>
      <div>Payment: {t(lookup("PaymentMethod", order.paymentMethod))}</div>
    </div>
  );
}

OrderStatusSelect.tsx
import { useTranslation } from "react-i18next";
import { lookup } from "../lookup/lookup";

const STATUSES = ["CREATED", "APPROVED", "CANCELLED"] as const;

export function OrderStatusSelect({ value, onChange }: { value: string, onChange: (v: string) => void }) {
  const { t } = useTranslation();

  return (
    <select value={value} onChange={e => onChange(e.target.value)}>
      {STATUSES.map(s => <option key={s}>{t(lookup("OrderStatus", s))}</option>)}
    </select>
  );
}

App.tsx
import { useEffect, useState } from "react";
import { useTranslation } from "react-i18next";
import { fetchOrder, Order } from "./api/orders";
import { OrderRow } from "./components/OrderRow";

export default function App() {
  const { i18n } = useTranslation();
  const [order, setOrder] = useState<Order | null>(null);

  useEffect(() => {
    fetchOrder().then(setOrder);
  }, []);

  return (
    <div>
      <button onClick={() => i18n.changeLanguage("en")}>EN</button>
      <button onClick={() => i18n.changeLanguage("fr")}>FR</button>

      {order && <OrderRow order={order} />}
    </div>
  );
}

âœ… Summary

Microservices â†’ enum codes only (OpenAPI defines them)

Node script â†’ generate JSON skeletons â†’ translators fill labels

Spring Boot BFF â†’ aggregates microservices + exposes lookup endpoints

React â†’ consumes codes + lookup bundles â†’ renders i18n labels

Optional dropdowns / tables / language switching

CI â†’ validate enum â†” JSON coverage

This is enterprise-grade, fully decoupled, scalable, and fits Spring Boot 4 + Jackson 3 + Java 25 + React i18n.

If you want, I can also make a diagram showing the full flow from OpenAPI â†’ BFF â†’ React with i18n and JSON bundles. This helps teams onboard fast.

Do you want me to make that diagram?

OK. All microservice's lookup data is static very rarly changes but one of the microservice's lookup data has its own definition screen. I mean new data can be added dynamically. How this special lookup can be handled in terms of i18n in this ecosystem?

Ah! Now weâ€™re talking about one microservice with dynamic lookup data, while all others remain static. This is a common real-world scenario, and it changes the i18n strategy slightly. Letâ€™s break it down carefully.

1ï¸âƒ£ Key facts

Most lookups â†’ static, generated once â†’ JSON bundles â†’ i18n labels â†’ React renders â†’ no backend localization required. âœ…

One microservice â†’ dynamic lookup data, editable by users/admins at runtime. âŒ

The problem: You cannot rely on pre-generated JSON bundles for this special lookup because new entries can appear after deployment.

2ï¸âƒ£ Strategy

We need a hybrid approach:

Lookup type	Source of truth	i18n approach
Static (most lookups)	OpenAPI enums	Pre-generated JSON bundles; React + BFF; CI validation
Dynamic (special lookup)	Microservice DB	Backend-resolved labels; BFF exposes localized API; optional fallback to UI editing
3ï¸âƒ£ Backend changes for dynamic lookup
3a. Store dynamic lookup entries

DB table: dynamic_lookup

id | code | default_label | locale | localized_label
---|------|---------------|--------|----------------
1  | VIP  | VIP Customer   | en     | VIP Customer
2  | VIP  | VIP Customer   | fr     | Client VIP


locale = null â†’ default label

localized_label â†’ per-language translation

3b. Admin screen

Microservice exposes CRUD endpoints

BFF can optionally expose UI-friendly aggregated lookup endpoint with localization

4ï¸âƒ£ BFF handling

Static lookups â†’ loaded from JSON bundles as before

Dynamic lookups â†’ fetched from microservice DB, possibly cached in memory

Example BFF endpoint
@GetMapping("/ui/lookups/special")
public List<LookupItem> dynamicLookup(
    @RequestHeader(name = "Accept-Language", defaultValue = "en") String lang
) {
    return dynamicLookupService.getAll(lang);
}

Service logic
public List<LookupItem> getAll(String lang) {
    List<DynamicLookup> entries = repository.findAll();
    return entries.stream()
        .map(e -> new LookupItem(
            e.getCode(),
            e.getLabelForLocale(lang) // fallback to default_label
        ))
        .toList();
}


âœ” React can call this endpoint dynamically
âœ” New entries appear instantly
âœ” Language switching supported

5ï¸âƒ£ React consumption

Same lookup() helper works for static lookups

For dynamic lookup:

async function fetchSpecialLookup(lang: string) {
  const res = await fetch(`/ui/lookups/special`, {
    headers: { "Accept-Language": lang }
  });
  return res.json(); // [{code, label}]
}


Can populate dropdowns, filters, tables dynamically

Supports locale switching

6ï¸âƒ£ Optional caching / optimization

Cache dynamic lookup in BFF for 10-60 seconds if reads are heavy

Use ETag or Last-Modified headers for React to avoid repeated fetching

7ï¸âƒ£ Mental model of the ecosystem
OpenAPI enums (static)  â†’ generate JSON â†’ BFF loads â†’ React renders
Dynamic lookup DB (special) â†’ BFF fetch + optional cache â†’ React fetches dynamically


Static lookups â†’ compile-time i18n

Dynamic lookups â†’ runtime i18n

Both coexist cleanly in the same frontend

8ï¸âƒ£ Key points

Donâ€™t pre-generate JSON for dynamic lookups; it changes at runtime.

Use Accept-Language / locale headers to fetch the correct labels.

Keep dynamic lookup i18n in the backend; React just consumes it.

Static lookups remain fully decoupled, so your current ecosystem stays intact.

âœ… This design ensures:

Static + dynamic lookups coexist

React and BFF can handle both

Language switching works everywhere

CI validations continue for static lookups

If you want, I can make a diagram showing this hybrid i18n flow in your ecosystem, highlighting static vs dynamic lookup handling. Itâ€™ll make this very clear to your team